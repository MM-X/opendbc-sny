diff --git a/opendbc/car/byd/__init__.py b/opendbc/car/byd/__init__.py
new file mode 100755
index 00000000..e69de29b
diff --git a/opendbc/car/byd/bydcan.py b/opendbc/car/byd/bydcan.py
new file mode 100755
index 00000000..e00fbc8a
--- /dev/null
+++ b/opendbc/car/byd/bydcan.py
@@ -0,0 +1,156 @@
+import numpy as np
+from opendbc.car import structs
+from opendbc.car.byd.values import  CanBus, CarControllerParams
+
+GearShifter = structs.CarState.GearShifter
+VisualAlert = structs.CarControl.HUDControl.VisualAlert
+
+def byd_checksum(byte_key, dat):
+    first_bytes_sum = sum(byte >> 4 for byte in dat)
+    second_bytes_sum = sum(byte & 0xF for byte in dat)
+    remainder = second_bytes_sum >> 4
+    second_bytes_sum += byte_key >> 4
+    first_bytes_sum += byte_key & 0xF
+    first_part = ((-first_bytes_sum + 0x9) & 0xF)
+    second_part = ((-second_bytes_sum + 0x9) & 0xF)
+    return (((first_part + (-remainder + 5)) << 4) + second_part) & 0xFF
+
+# MPC -> Panda -> EPS
+def create_steering_control(packer, CP, cam_msg: dict, req_torque, req_prepare, active, hud_control, counter):
+    values = {}
+    values = {s: cam_msg[s] for s in [
+        "AutoFullBeamState",
+        "LeftLaneState",
+        "LKAS_Config",
+        "SETME2_0x1",
+        "MPC_State",
+        "AutoFullBeam_OnOff",
+        "LKAS_Output",
+        "LKAS_Active",
+        "SETME3_0x0",
+        "TrafficSignRecognition_OnOff",
+        "SETME4_0x0",
+        "SETME5_0x1",
+        "RightLaneState",
+        "LKAS_State",
+        "TrafficSignRecognition_Result",
+        "LKAS_AlarmType",
+        "SETME7_0x3",
+    ]}
+
+    values["ReqHandsOnSteeringWheel"] = 0
+    values["LKAS_ReqPrepare"] = req_prepare
+    values["Counter"] = counter
+
+    if active:
+        mpc_state = values["MPC_State"] #2: Cancelling lkas control
+        values.update({
+            "LKAS_Output" : req_torque,
+            "LKAS_Active" : 1,
+            "LKAS_State" : 4 if (mpc_state == 2) else 2,
+            "LeftLaneState":  3 if hud_control.leftLaneDepart  else int(hud_control.leftLaneVisible) + 1,
+            "RightLaneState": 3 if hud_control.rightLaneDepart else int(hud_control.rightLaneVisible) + 1,
+        })
+    else: # Note: This disables the stock AEB feature: turn steering wheel while close impacting obstacles in front.
+        values.update({
+            "LKAS_Output" : 0,
+            "LKAS_Active" : 0,
+        })
+
+    data = packer.make_can_msg("ACC_MPC_STATE", CanBus.ESC, values)[1]
+    values["CheckSum"] = byd_checksum(0xAF, data)
+    return packer.make_can_msg("ACC_MPC_STATE", CanBus.ESC, values)
+
+# op long control
+def acc_cmd(packer, CP, cam_msg: dict, mrr_leaddist, accel, rfss, sss, longActive):
+    values = {}
+
+    values = {s: cam_msg[s] for s in [
+        "AccelCmd",
+        "ComfortBandUpper",
+        "ComfortBandLower",
+        "JerkUpperLimit",
+        "SETME1_0x1",
+        "JerkLowerLimit",
+        "ResumeFromStandstill",
+        "StandstillState",
+        "BrakeBehaviour",
+        "AccReqNotStandstill",
+        "AccControlActive",
+        "AccOverrideOrStandstill",
+        "EspBehaviour",
+        "Counter",
+        "SETME2_0xF",
+    ]}
+
+    jerk_base_upper = np.interp(mrr_leaddist, CarControllerParams.K_jerk_xp, CarControllerParams.K_jerk_base_upper_fp)
+    jerk_base_lower = np.interp(mrr_leaddist, CarControllerParams.K_jerk_xp, CarControllerParams.K_jerk_base_lower_fp)
+
+    if (accel < 0): #use lower factor
+        jerk_upper = jerk_base_upper
+        jerk_lower = jerk_base_lower + accel * CarControllerParams.K_accel_jerk_lower
+    else:
+        jerk_upper = jerk_base_upper + accel * CarControllerParams.K_accel_jerk_upper
+        jerk_lower = jerk_base_lower
+
+    if longActive :
+        values.update({
+            "AccelCmd" : accel,
+            "ComfortBandUpper" : 0.05 if mrr_leaddist > 50 else 0.10,
+            "ComfortBandLower" : 0.05 if mrr_leaddist > 50 else 0.10,
+            "JerkUpperLimit" : jerk_upper,
+            "JerkLowerLimit" : jerk_lower,
+            "ResumeFromStandstill" : rfss,
+            "StandstillState" : sss,
+        })
+
+    data = packer.make_can_msg("ACC_CMD", CanBus.ESC, values)[1]
+    values["CheckSum"] = byd_checksum(0xAF, data)
+    return packer.make_can_msg("ACC_CMD", CanBus.ESC, values)
+
+# send fake torque feedback from eps to trick MPC, preventing DTC, so that safety features such as AEB still working
+def create_fake_318(packer, CP, esc_msg: dict, faketorque, laks_reqprepare, laks_active , enabled, counter):
+    values = {}
+
+    values = {s: esc_msg[s] for s in [
+        "LKAS_Prepared",
+        "CruiseActivated",
+        "TorqueFailed",
+        "SETME1_0x1",
+        "SteerWarning",
+        "SteerErrorCode",
+        "MainTorque",
+        "SETME3_0x1",
+        "SETME4_0x3",
+        "SteerDriverTorque",
+        "SETME5_0xFF",
+        "SETME6_0xFFF",
+    ]}
+
+    values["ReportHandsNotOnSteeringWheel"] = 0
+    values["Counter"] = counter
+
+    if enabled :
+        if laks_active:
+            values.update({
+                "LKAS_Prepared" : 0,
+                "CruiseActivated" : 1,
+                "MainTorque" : faketorque,
+            })
+        elif laks_reqprepare:
+            values.update({
+                "LKAS_Prepared" : 1,
+                "CruiseActivated" : 0,
+                "MainTorque" : 0,
+            })
+        else:
+            values.update({
+                "LKAS_Prepared" : 0,
+                "CruiseActivated" : 0,
+                "MainTorque" : 0,
+            })
+
+
+    data = packer.make_can_msg("ACC_EPS_STATE", CanBus.MPC, values)[1]
+    values["CheckSum"] = byd_checksum(0xAF, data)
+    return packer.make_can_msg("ACC_EPS_STATE", CanBus.MPC, values)
diff --git a/opendbc/car/byd/carcontroller.py b/opendbc/car/byd/carcontroller.py
new file mode 100755
index 00000000..a4575483
--- /dev/null
+++ b/opendbc/car/byd/carcontroller.py
@@ -0,0 +1,178 @@
+import numpy as np
+from opendbc.can.packer import CANPacker
+from opendbc.car import Bus, apply_driver_steer_torque_limits, structs
+from opendbc.car.interfaces import CarControllerBase
+from opendbc.car.byd import bydcan
+from opendbc.car.byd.values import CarControllerParams
+
+VisualAlert = structs.CarControl.HUDControl.VisualAlert
+ButtonType = structs.CarState.ButtonEvent.Type
+LongCtrlState = structs.CarControl.Actuators.LongControlState
+
+class CarController(CarControllerBase):
+  def __init__(self, dbc_names, CP):
+    super().__init__(dbc_names, CP)
+
+    self.packer = CANPacker(dbc_names[Bus.pt])
+
+    self.frame = 0
+    self.last_steer_frame = 0
+    self.last_acc_frame = 0
+
+    self.apply_torque_last = 0
+
+    self.mpc_lkas_counter = 0
+    self.mpc_acc_counter = 0
+    self.eps_fake318_counter = 0
+
+    self.lkas_req_prepare = 0
+    self.lkas_active = 0
+    self.lat_safeoff = 0
+
+    self.steer_softstart_limit = 0
+    self.steerRateLimActive = False
+    self.steerRateLim = 1.0
+
+    self.first_start = True
+    self.rfss = 0 # resume from stand still
+    self.sss = 0 #stand still state
+
+    self.apply_accel_last = 0
+
+
+  def update(self, CC, CS, now_nanos):
+    can_sends = []
+
+    if (self.frame - self.last_steer_frame) >= CarControllerParams.STEER_STEP:
+
+      #Resolve counter mismatch problem
+      if self.first_start:
+        self.mpc_lkas_counter = int(CS.acc_mpc_state_counter + 1) & 0xF
+        self.mpc_acc_counter = int(CS.acc_cmd_counter + 1) & 0xF
+        self.eps_fake318_counter = int(CS.eps_state_counter + 1) & 0xF
+        self.first_start = False
+
+      apply_torque = 0
+
+      if CC.latActive:
+        if self.lkas_active:
+          steer_desire = CC.actuators.torque
+
+          if CarControllerParams.USE_STEERING_SPEED_LIMITER: #Use steering angular speed limiter
+            rate_limit = np.interp(CS.out.aEgo, [8.3, 27.8], [132, 64])
+            delta_rate = CS.steeringRateDegAbs - rate_limit
+
+            if delta_rate < 0:
+              self.steerRateLim -= 0.005 * delta_rate
+
+              if delta_rate < -0.05:
+                self.steerRateLimActive = False
+
+              if self.steerRateLim > 1.0:
+                self.steerRateLim = 1.0
+                self.steerRateLimActive = False
+
+            else:
+              if self.steerRateLimActive:
+                self.steerRateLim -= 0.005 * delta_rate
+              else:
+                self.steerRateLim = steer_desire
+                self.steerRateLimActive = True
+
+              if self.steerRateLim < 0:
+                self.steerRateLim = 0
+
+            new_steer_pu = np.clip(steer_desire, -self.steerRateLim, self.steerRateLim)
+          else:
+            new_steer_pu = steer_desire
+
+          new_steer = int(round(new_steer_pu * CarControllerParams.STEER_MAX))
+
+          if self.steer_softstart_limit < CarControllerParams.STEER_MAX :
+            self.steer_softstart_limit = self.steer_softstart_limit + CarControllerParams.STEER_SOFTSTART_STEP
+            new_steer = np.clip(new_steer, -self.steer_softstart_limit, self.steer_softstart_limit)
+
+          apply_torque = apply_driver_steer_torque_limits(new_steer, self.apply_torque_last,
+                                                          CS.out.steeringTorque, CarControllerParams)
+
+        else :
+          if CS.lkas_prepared:
+            self.lkas_active = 1.0
+            self.steerRateLimActive = False
+            self.steerRateLim = 1.0
+            self.lkas_req_prepare = 0
+            self.steer_softstart_limit = 0
+            self.lat_safeoff = 1
+          else:
+            self.lkas_req_prepare = 1
+
+      elif self.lat_safeoff:
+        if self.apply_torque_last == 0:
+          self.lat_safeoff = 0
+        apply_torque = apply_driver_steer_torque_limits(0, self.apply_torque_last,
+                                                          CS.out.steeringTorque, CarControllerParams)
+
+      else:
+        self.lkas_req_prepare = 0
+        self.steerRateLimActive = False
+        self.steerRateLim = 1.0
+        self.lkas_active = 0
+        self.soft_start_torque_limit = 0
+        self.steer_softstart_limit = 0
+
+      self.apply_torque_last = apply_torque
+
+      self.mpc_lkas_counter = int(self.mpc_lkas_counter + 1) & 0xF
+      self.eps_fake318_counter = int(self.eps_fake318_counter + 1) & 0xF
+      self.last_steer_frame = self.frame
+
+      # send steering command, op to esc
+      can_sends.append(bydcan.create_steering_control(self.packer, self.CP, CS.cam_lkas,
+          self.apply_torque_last, self.lkas_req_prepare, self.lkas_active, CC.hudControl, self.mpc_lkas_counter))
+
+      # send fake 318 from op to mpc
+      can_sends.append(bydcan.create_fake_318(self.packer, self.CP, CS.esc_eps,
+                                              CS.mpc_laks_output, CS.mpc_laks_reqprepare, CS.mpc_laks_active,
+                                              True, self.eps_fake318_counter))
+
+    if (self.frame + 1 - self.last_acc_frame) >= CarControllerParams.ACC_STEP:
+      accel = np.clip(CC.actuators.accel, CarControllerParams.ACCEL_MIN, CarControllerParams.ACCEL_MAX)
+
+      if CC.longActive :
+        stopping = CC.actuators.longControlState == LongCtrlState.stopping
+        starting = CC.actuators.longControlState == LongCtrlState.starting
+        running = CC.actuators.longControlState == LongCtrlState.pid
+
+        #stopping and stopped
+        if stopping and accel < -0.1 : # and CS.mrr_leading_dist < 4:
+            self.rfss = 0
+            self.sss = CS.out.standstill
+
+        #re-starting
+        elif starting and accel > 0.1 and CS.mrr_leading_dist > 3:
+          self.rfss = CS.out.standstill
+          self.sss = 0
+
+        #started
+        elif running:
+          self.rfss = 0
+          self.sss = 0
+
+      else:
+        accel = 0
+        self.sss = 0
+        self.rfss = 0
+
+      can_sends.append(bydcan.acc_cmd(self.packer, self.CP, CS.cam_acc, CS.mrr_leading_dist, accel, self.rfss, self.sss, CC.longActive))
+
+      self.apply_accel_last = accel
+      self.last_acc_frame = self.frame + 1
+
+    new_actuators = CC.actuators.as_builder()
+    new_actuators.torque = self.apply_torque_last / CarControllerParams.STEER_MAX
+    new_actuators.torqueOutputCan = self.apply_torque_last
+    new_actuators.accel = float(self.apply_accel_last)
+    new_actuators.steeringAngleDeg = float(CS.out.steeringAngleDeg)
+
+    self.frame += 1
+    return new_actuators, can_sends
diff --git a/opendbc/car/byd/carstate.py b/opendbc/car/byd/carstate.py
new file mode 100755
index 00000000..ff86f210
--- /dev/null
+++ b/opendbc/car/byd/carstate.py
@@ -0,0 +1,254 @@
+import copy
+import numpy as np
+
+#-----disabled for pytests-----
+#from datetime import datetime, timedelta
+#import subprocess
+#from openpilot.common.time_helpers import system_time_valid
+#from openpilot.common.swaglog import cloudlog
+
+from opendbc.can.can_define import CANDefine
+from opendbc.can.parser import CANParser
+
+from opendbc.car.common.conversions import Conversions as CV
+#from opendbc.car.common.numpy_fast import mean
+from opendbc.car import Bus, create_button_events, structs
+from opendbc.car.interfaces import CarStateBase
+from opendbc.car.byd.values import DBC, CanBus, LKASConfig, CarControllerParams
+
+ButtonType = structs.CarState.ButtonEvent.Type
+
+class CarState(CarStateBase):
+    def __init__(self, CP):
+        super().__init__(CP)
+
+        can_define = CANDefine(DBC[CP.carFingerprint][Bus.pt])
+
+        self.shifter_values = can_define.dv["DRIVE_STATE"]["Gear"]
+
+        self.speed_kph = 0
+
+        self.mpc_lkas_config = 0
+
+        self.acc_hud_adas_counter = 0
+        self.acc_mpc_state_counter = 0
+        self.acc_cmd_counter = 0
+
+        self.eps_warning = False
+
+        self.acc_active_last = False
+        self.low_speed_alert = False
+        self.lkas_allowed_speed = False
+
+        self.lkas_prepared = False  #318, EPS to OP
+        self.acc_state = 0
+        self.adas_set_dist = 0
+
+        self.mpc_laks_output = 0
+        self.mpc_laks_active = False
+        self.mpc_laks_reqprepare = False
+
+        #self.prev_angle = 0
+
+        self.cam_lkas = 0
+        self.cam_acc = 0
+        self.esc_eps = 0
+
+        self.setTimeDelay = 100
+
+        self.mrr_leading_dist = 0
+
+        self.btn_acc_cancel = 0
+        self.btn_acc_set_reset = 0
+        self.btn_acc_dist_inc = 0
+        self.btn_acc_dist_dec = 0
+
+        self.prev_steeringAngleDeg = 0
+        #self.steeringRate = 0.0
+        self.steeringRateDegAbs = 0
+
+
+
+    def update(self, can_parsers) -> structs.CarState: # type: ignore
+        cp = can_parsers[Bus.pt]
+        cp_cam = can_parsers[Bus.cam]
+
+        ret = structs.CarState()
+
+        self.lkas_prepared = cp.vl["ACC_EPS_STATE"]["LKAS_Prepared"]
+
+        self.mpc_lkas_config = int(cp_cam.vl["ACC_MPC_STATE"]["LKAS_Config"])
+        lkas_config_isAccOn = (self.mpc_lkas_config != LKASConfig.DISABLE)
+        lkas_isMainSwOn = bool(cp.vl["PCM_BUTTONS"]["BTN_TOGGLE_ACC_OnOff"])
+
+        lkas_hud_AccOn1 = bool(cp_cam.vl["ACC_HUD_ADAS"]["AccOn1"])
+        self.acc_state  = cp_cam.vl["ACC_HUD_ADAS"]["AccState"]
+        self.adas_set_dist = cp_cam.vl["ACC_HUD_ADAS"]["SetDistance"]
+
+        prev_btn_acc_cancel = self.btn_acc_cancel
+        prev_btn_acc_set_reset = self.btn_acc_set_reset
+        prev_btn_acc_dist_inc = self.btn_acc_dist_inc
+        prev_btn_acc_dist_dec = self.btn_acc_dist_dec
+
+        self.btn_acc_cancel = cp.vl["PCM_BUTTONS"]["BTN_AccCancel"]
+        self.btn_acc_set_reset = cp.vl["PCM_BUTTONS"]["BTN_AccCancel"]
+        self.btn_acc_dist_inc = cp.vl["PCM_BUTTONS"]["BTN_AccDistanceIncrease"]
+        self.btn_acc_dist_dec = cp.vl["PCM_BUTTONS"]["BTN_AccDistanceDecrease"]
+
+        # use wheels averages if you like
+        # ret.wheelSpeeds = self.get_wheel_speeds(
+        #     cp.vl["IPB"]["WheelSpeed_FL"],
+        #     cp.vl["IPB"]["WheelSpeed_FR"],
+        #     cp.vl["IPB"]["WheelSpeed_RL"],
+        #     cp.vl["IPB"]["WheelSpeed_RR"],
+        # )
+        #speed_kph = mean([ret.wheelSpeeds.fl, ret.wheelSpeeds.fr, ret.wheelSpeeds.rl, ret.wheelSpeeds.rr])
+
+        # use dash speedo as speed reference
+        speed_raw = int(cp.vl["CARSPEED"]["CarDisplaySpeed"])
+        speed_raw_kph = speed_raw * CarControllerParams.K_DASHSPEED
+        correct_factor = np.interp(speed_raw_kph, [30, 60, 90, 120], [1., 1., 1., 1.])
+        self.speed_kph = speed_raw_kph * correct_factor
+
+        ret.vEgoRaw = float(self.speed_kph * CV.KPH_TO_MS) # KPH to m/s
+        ret.vEgo, ret.aEgo = self.update_speed_kf(ret.vEgoRaw)
+
+        ret.standstill = (speed_raw == 0)
+
+        if self.CP.minSteerSpeed > 0:
+            if self.speed_kph > 0.5:
+                self.lkas_allowed_speed = True
+            elif self.speed_kph < 0.1:
+                self.lkas_allowed_speed = False
+        else:
+            self.lkas_allowed_speed = True
+
+        can_gear = int(cp.vl["DRIVE_STATE"]["Gear"])
+        ret.gearShifter = self.parse_gear_shifter(self.shifter_values.get(can_gear, None))
+
+        ret.genericToggle = bool(cp.vl["STALKS"]["HeadLight"])
+        if self.CP.enableBsm:
+            ret.leftBlindspot = bool(cp.vl["BSD_RADAR"]["LEFT_APPROACH"])
+            ret.rightBlindspot = bool(cp.vl["BSD_RADAR"]["RIGHT_APPROACH"])
+
+        ret.leftBlinker = bool(cp.vl["STALKS"]["LeftIndicator"])
+        ret.rightBlinker = bool(cp.vl["STALKS"]["RightIndicator"])
+
+        ret.steeringAngleOffsetDeg = 0
+        ret.steeringAngleDeg = cp.vl["EPS"]["SteeringAngle"]
+
+        self.steeringRateDegAbs = cp.vl["EPS"]["SteeringAngleRate"]
+        ret.steeringRateDeg = self.steeringRateDegAbs
+
+        ret.steeringTorque = cp.vl["ACC_EPS_STATE"]["SteerDriverTorque"]
+        ret.steeringTorqueEps = cp.vl["ACC_EPS_STATE"]["MainTorque"]
+        self.eps_warning = bool(cp.vl["ACC_EPS_STATE"]["SteerWarning"]) #Todo: some firmware have SteerWarning field asserted.
+        self.eps_state_counter = int(cp.vl["ACC_EPS_STATE"]["Counter"])
+
+        ret.steeringPressed = self.update_steering_pressed(abs(ret.steeringTorque) > 59, 5)
+
+        ret.parkingBrake = (cp.vl["EPB"]["EPB_ActiveFlag"] == 1)
+
+        ret.brake =  int(cp.vl["PEDAL"]["BrakePedal"])
+        ret.brakePressed = (ret.brake != 0)
+
+        ret.seatbeltUnlatched = (cp.vl["BCM"]["DriverSeatBeltFasten"] != 1)
+
+        ret.doorOpen = any([cp.vl["BCM"]["FrontLeftDoor"], cp.vl["BCM"]["FrontRightDoor"],
+                            cp.vl["BCM"]["RearLeftDoor"],  cp.vl["BCM"]["RearRightDoor"]])
+
+        ret.gas = int(cp.vl["PEDAL"]["AcceleratorPedal"])
+        ret.gasPressed = (ret.gas != 0)
+
+        ret.cruiseState.available = lkas_isMainSwOn and lkas_config_isAccOn and lkas_hud_AccOn1
+        ret.cruiseState.enabled = self.acc_state in (3, 5)
+        ret.cruiseState.standstill = ret.standstill
+        ret.cruiseState.speed = cp_cam.vl["ACC_HUD_ADAS"]["SetSpeed"] * CV.KPH_TO_MS
+
+        #Todo: some firmware have these fields asserted.
+        ret.steerFaultTemporary = bool((self.acc_state == 7) or self.eps_warning)
+
+        self.acc_active_last = ret.cruiseState.enabled
+
+        self.mpc_laks_output = cp_cam.vl["ACC_MPC_STATE"]["LKAS_Output"] #use to fool mpc
+        self.mpc_laks_reqprepare = cp_cam.vl["ACC_MPC_STATE"]["LKAS_ReqPrepare"] != 0 #use to fool mpc
+        self.mpc_laks_active = cp_cam.vl["ACC_MPC_STATE"]["LKAS_Active"] != 0 #use to fool mpc
+
+        self.acc_hud_adas_counter = cp_cam.vl["ACC_HUD_ADAS"]["Counter"]
+        self.acc_mpc_state_counter = cp_cam.vl["ACC_MPC_STATE"]["Counter"]
+        self.acc_cmd_counter = cp_cam.vl["ACC_CMD"]["Counter"]
+
+        self.cam_lkas = copy.copy(cp_cam.vl["ACC_MPC_STATE"])
+        self.cam_adas = copy.copy(cp_cam.vl["ACC_HUD_ADAS"])
+        self.cam_acc = copy.copy(cp_cam.vl["ACC_CMD"])
+        self.esc_eps = copy.copy(cp.vl["ACC_EPS_STATE"])
+
+        mrr_id = int(cp_cam.vl["RADAR_MRR"]["TargetID"])
+
+        if mrr_id == 2: #1:left, 2:front, 3:right
+            if bool(cp_cam.vl["RADAR_MRR"]["IsValid"]):
+                self.mrr_leading_dist = int(cp_cam.vl["RADAR_MRR"]["LongDist"])
+            else:
+                self.mrr_leading_dist = 199
+
+        ret.steerFaultPermanent = bool(cp.vl["ACC_EPS_STATE"]["TorqueFailed"]) #EPS give up all inputs until restart
+
+        # if self.setTimeDelay == 0:
+        #     if not system_time_valid():
+        #         yyyy = int(cp.vl["DATETIME"]["YY"] + 2000)
+        #         MM = int(cp.vl["DATETIME"]["MM"])
+        #         DD = int(cp.vl["DATETIME"]["DD"])
+        #         hh = int(cp.vl["DATETIME"]["hh"])
+        #         mm = int(cp.vl["DATETIME"]["mm"])
+        #         ss = int(cp.vl["DATETIME"]["ss"])
+        #         china_time = datetime(yyyy,MM,DD,hh,mm,ss)
+        #         china_utc_offset = timedelta(hours=8)
+        #         utc_time = china_time - china_utc_offset
+        #         cloudlog.debug(f"Setting time to {utc_time}")
+        #         try:
+        #             subprocess.run(f"TZ=UTC date -s '{utc_time}'", shell=True, check=True)
+        #         except subprocess.CalledProcessError:
+        #             cloudlog.exception("timed.failed_setting_time")
+        # else:
+        #     self.setTimeDelay = self.setTimeDelay - 1
+
+        ret.buttonEvents = [
+            *create_button_events(self.btn_acc_cancel, prev_btn_acc_cancel, {1: ButtonType.cancel}),
+            *create_button_events(self.btn_acc_set_reset, prev_btn_acc_set_reset, {1: ButtonType.decelCruise, 3: ButtonType.accelCruise}),
+            *create_button_events(self.btn_acc_dist_inc, prev_btn_acc_dist_inc, {1: ButtonType.gapAdjustCruise}),
+            *create_button_events(self.btn_acc_dist_dec, prev_btn_acc_dist_dec, {1: ButtonType.gapAdjustCruise}),
+        ]
+
+        return ret
+
+
+    @staticmethod
+    def get_can_parsers(CP):
+        pt_messages = [
+            # sig_address, frequency
+            ("EPS", 100),
+            ("CARSPEED", 50),
+            ("PEDAL", 50),
+            ("EPB", 1),
+            ("ACC_EPS_STATE", 50),
+            ("DRIVE_STATE", 50),
+            ("STALKS", 1),
+            ("BCM", 1),
+            ("PCM_BUTTONS", 20),
+            ("DATETIME", 2),
+        ]
+
+        if CP.enableBsm:
+            pt_messages.append(("BSD_RADAR", 20))
+
+        cam_messages = [
+            ("ACC_HUD_ADAS", 50),
+            ("ACC_CMD", 50),
+            ("ACC_MPC_STATE", 50),
+            ("RADAR_MRR", 60),
+        ]
+
+        return {
+            Bus.pt: CANParser(DBC[CP.carFingerprint][Bus.pt], pt_messages, CanBus.ESC),
+            Bus.cam: CANParser(DBC[CP.carFingerprint][Bus.pt], cam_messages, CanBus.MPC),
+        }
\ No newline at end of file
diff --git a/opendbc/car/byd/fingerprints.py b/opendbc/car/byd/fingerprints.py
new file mode 100755
index 00000000..6d210fe2
--- /dev/null
+++ b/opendbc/car/byd/fingerprints.py
@@ -0,0 +1,48 @@
+# ruff: noqa: E501
+from opendbc.car.structs import CarParams
+from opendbc.car.byd.values import CAR
+
+Ecu = CarParams.Ecu
+
+# Todo: could fingerprints for song dmi be able to combine?
+FINGERPRINTS = {
+  CAR.BYD_HAN_DM_20: [{
+    85: 8, 140: 8, 213: 8, 269: 8, 287: 5, 289: 8, 290: 8, 291: 8, 301: 8, 303: 8, 307: 8, 309: 8, 315: 8, 384: 8, 496: 8, 530: 8, 536: 8, 544: 8, 546: 8, 547: 8, 576: 8, 578: 8, 588: 8, 660: 8, 694: 8, 790: 8, 792: 8, 797: 8, 798: 8, 801: 8, 802: 8, 813: 8, 814: 8, 815: 8, 833: 8, 834: 8, 836: 8, 843: 8, 860: 8, 884: 8, 916: 8, 918: 8, 926: 8, 940: 8, 941: 8, 944: 8, 948: 8, 985: 8, 988: 8, 1004: 8, 1020: 8, 1037: 8, 1040: 8, 1058: 8, 1074: 8, 1141: 8, 1172: 8, 1178: 8, 1180: 8, 1193: 8, 1246: 8, 1293: 8, 1793: 8, 1796: 8, 1804: 8, 1904: 8, 1905: 8, 1912: 8, 1913: 8, 1986: 8, 2004: 8, 2034: 8, 2042: 8
+  }],
+  CAR.BYD_HAN_EV_20: [{
+    85: 8, 140: 8, 213: 8, 287: 5, 289: 8, 290: 8, 291: 8, 301: 8, 303: 8, 307: 8, 308: 8, 309: 8, 315: 8, 464: 8, 465: 8, 480: 8, 496: 8, 536: 8, 544: 8, 546: 8, 547: 8, 576: 8, 578: 8, 588: 8, 660: 8, 694: 8, 790: 8, 792: 8, 797: 8, 798: 8, 801: 8, 802: 8, 812: 8, 813: 8, 814: 8, 815: 8, 833: 8, 834: 8, 836: 8, 843: 8, 860: 8, 863: 8, 879: 8, 884: 8, 916: 8, 918: 8, 920: 8, 926: 8, 940: 8, 941: 8, 944: 8, 948: 8, 965: 8, 976: 8, 985: 8, 988: 8, 1004: 8, 1020: 8, 1036: 8, 1037: 8, 1040: 8, 1048: 8, 1058: 8, 1074: 8, 1141: 8, 1172: 8, 1178: 8, 1180: 8, 1193: 8, 1246: 8, 1268: 8, 1793: 8, 1794: 8, 1797: 8, 1798: 8, 1801: 8, 1808: 8, 1809: 8, 1811: 8, 1812: 8, 1824: 8, 1827: 8, 1828: 8, 1829: 8, 1830: 8, 1842: 8, 1843: 8, 1845: 8, 1847: 8, 1858: 8, 1859: 8, 1862: 8, 1863: 8, 1872: 8, 1873: 8, 1874: 8, 1876: 8, 1890: 8, 1891: 8, 1894: 8, 1904: 8, 1905: 8, 1912: 8, 1913: 8, 1920: 8, 1921: 8, 1922: 8, 1923: 8, 1925: 8, 1927: 8, 1939: 8, 1940: 8, 1943: 8, 1959: 8, 1971: 8, 1973: 8, 1984: 8, 1986: 8, 1987: 8, 1991: 8, 1994: 8, 2002: 8, 2004: 8, 2006: 8, 2012: 8, 2033: 8, 2034: 8, 2042: 8
+  }],
+  CAR.BYD_TANG_DM: [{
+    85: 8, 140: 8, 256: 8, 269: 8, 270: 8, 287: 5, 289: 8, 290: 8, 291: 8, 301: 8, 307: 8, 315: 8, 464: 8, 496: 8, 522: 8, 523: 8, 527: 8, 530: 8, 536: 8, 537: 8, 544: 8, 546: 8, 547: 8, 576: 8, 577: 8, 578: 8, 588: 8, 593: 8, 596: 8, 636: 8, 660: 8, 694: 8, 769: 8, 770: 8, 784: 8, 788: 8, 790: 8, 792: 8, 800: 8, 801: 8, 802: 8, 813: 8, 814: 8, 815: 8, 832: 8, 833: 8, 834: 8, 835: 8, 836: 8, 838: 8, 839: 8, 841: 8, 842: 8, 848: 8, 849: 8, 850: 8, 851: 8, 852: 8, 854: 8, 860: 8, 896: 8, 897: 8, 898: 8, 899: 8, 900: 8, 901: 8, 902: 8, 903: 8, 904: 8, 905: 8, 906: 8, 907: 8, 908: 8, 909: 8, 910: 8, 911: 8, 912: 8, 913: 8, 914: 8, 915: 8, 916: 8, 917: 8, 918: 8, 919: 8, 926: 8, 944: 8, 948: 8, 968: 8, 969: 8, 970: 8, 971: 8, 972: 8, 973: 8, 974: 8, 975: 8, 976: 8, 977: 8, 978: 8, 979: 8, 980: 8, 981: 8, 982: 8, 983: 8, 984: 8, 985: 8, 986: 8, 987: 8, 988: 8, 989: 8, 990: 8, 991: 8, 992: 8, 993: 8, 994: 8, 995: 8, 996: 8, 997: 8, 998: 8, 999: 8, 1000: 8, 1001: 8, 1002: 8, 1003: 8, 1004: 8, 1005: 8, 1006: 8, 1007: 8, 1008: 8, 1009: 8, 1010: 8, 1011: 8, 1012: 8, 1013: 8, 1014: 8, 1015: 8, 1016: 8, 1017: 8, 1018: 8, 1019: 8, 1020: 8, 1021: 8, 1022: 8, 1023: 8, 1037: 8, 1040: 8, 1058: 8, 1074: 8, 1104: 8, 1141: 8, 1172: 8, 1178: 8, 1181: 8, 1193: 8, 1219: 8, 1224: 8, 1246: 8, 1385: 8, 1809: 8, 1817: 8, 1840: 8, 1848: 8, 1872: 8, 1873: 8, 1874: 8, 1875: 8, 1876: 8, 1877: 8, 1878: 8, 1879: 8, 1880: 8, 1881: 8, 1882: 8, 1883: 8, 1884: 8, 1885: 8, 1886: 8, 1887: 8, 1906: 8, 1914: 8, 1973: 8, 1974: 8, 1975: 8, 1981: 8, 1982: 8, 1983: 8, 1991: 8, 2006: 8, 2017: 8, 2025: 8, 2032: 8, 2040: 8, 134117888: 8
+  }],
+  CAR.BYD_TANG_DMI_21: [{
+    85: 8, 140: 8, 213: 8, 269: 8, 270: 8, 287: 5, 289: 8, 290: 8, 291: 8, 300: 8, 301: 8, 307: 8, 309: 8, 337: 8, 356: 8, 371: 8, 384: 8, 418: 8, 450: 8, 496: 8, 522: 8, 525: 8, 527: 8, 536: 8, 537: 8, 544: 8, 546: 8, 547: 8, 575: 8, 576: 8, 577: 8, 578: 8, 587: 8, 588: 8, 593: 8, 629: 8, 635: 8, 638: 8, 660: 8, 665: 8, 681: 8, 694: 8, 703: 8, 724: 8, 733: 8, 748: 8, 775: 8, 777: 8, 781: 8, 790: 8, 792: 8, 797: 8, 798: 8, 800: 8, 801: 8, 802: 8, 803: 8, 812: 8, 813: 8, 814: 8, 815: 8, 827: 8, 828: 8, 829: 8, 833: 8, 834: 8, 835: 8, 836: 8, 843: 8, 847: 8, 854: 8, 860: 8, 863: 8, 878: 8, 879: 8, 884: 8, 906: 8, 940: 8, 941: 8, 944: 8, 948: 8, 951: 8, 965: 8, 973: 8, 985: 8, 1004: 8, 1023: 8, 1028: 8, 1031: 8, 1036: 8, 1037: 8, 1038: 8, 1040: 8, 1048: 8, 1052: 8, 1058: 8, 1074: 8, 1076: 8, 1097: 8, 1098: 8, 1141: 8, 1163: 8, 1178: 8, 1189: 8, 1193: 8, 1215: 8, 1246: 8, 1263: 8, 1273: 8, 1274: 8, 1297: 8, 1298: 8, 1337: 8, 1338: 8, 1609: 8, 1613: 8, 1649: 8, 1792: 8, 1793: 8, 1798: 8, 1799: 8, 1810: 8, 1813: 8, 1824: 8, 1825: 8, 1832: 8, 1840: 8, 1842: 8, 1856: 8, 1858: 8, 1859: 8, 1860: 8, 1862: 8, 1863: 8, 1864: 8, 1871: 8, 1872: 8, 1875: 8, 1879: 8, 1882: 8, 1888: 8, 1889: 8, 1892: 8, 1902: 8, 1912: 8, 1913: 8, 1920: 8, 1927: 8, 1937: 8, 1948: 8, 1953: 8, 1954: 8, 1955: 8, 1968: 8, 1969: 8, 1971: 8, 1975: 8, 1976: 8, 1979: 8, 1988: 8, 1990: 8, 2000: 8, 2001: 8, 2004: 8, 2009: 8, 2012: 8, 2017: 8, 2018: 8, 2020: 8, 2026: 8, 2027: 8, 2030: 8, 2033: 8, 2041: 8
+  }],
+  CAR.BYD_SONG_PLUS_DMI_21: [{
+    85: 8, 140: 8, 213: 8, 269: 8, 270: 8, 287: 5, 289: 8, 290: 8, 291: 8, 301: 8, 307: 8, 337: 8, 356: 8, 371: 8, 418: 8, 450: 8, 496: 8, 522: 8, 525: 8, 527: 8, 536: 8, 537: 8, 544: 8, 546: 8, 547: 8, 575: 8, 576: 8, 577: 8, 578: 8, 588: 8, 593: 8, 629: 8, 638: 8, 660: 8, 694: 8, 724: 8, 748: 8, 781: 8, 786: 8, 790: 8, 792: 8, 797: 8, 798: 8, 800: 8, 801: 8, 802: 8, 803: 8, 812: 8, 813: 8, 814: 8, 815: 8, 827: 8, 828: 8, 829: 8, 833: 8, 834: 8, 835: 8, 836: 8, 847: 8, 854: 8, 860: 8, 863: 8, 878: 8, 879: 8, 906: 8, 940: 8, 941: 8, 944: 8, 951: 8, 965: 8, 973: 8, 985: 8, 1004: 8, 1020: 8, 1023: 8, 1028: 8, 1031: 8, 1037: 8, 1038: 8, 1040: 8, 1048: 8, 1052: 8, 1058: 8, 1074: 8, 1076: 8, 1097: 8, 1098: 8, 1141: 8, 1178: 8, 1189: 8, 1193: 8, 1215: 8, 1246: 8, 1273: 8, 1274: 8, 1278: 8, 1297: 8, 1298: 8, 1319: 8, 1322: 8, 1337: 8, 1338: 8, 1687: 8}, {85: 8, 140: 8, 213: 8, 269: 8, 270: 8, 287: 5, 289: 8, 290: 8, 291: 8, 300: 8, 301: 8, 307: 8, 309: 8, 337: 8, 356: 8, 371: 8, 427: 8, 450: 8, 496: 8, 522: 8, 525: 8, 527: 8, 536: 8, 537: 8, 544: 8, 546: 8, 547: 8, 575: 8, 576: 8, 577: 8, 578: 8, 588: 8, 593: 8, 629: 8, 638: 8, 660: 8, 681: 8, 694: 8, 703: 8, 724: 8, 748: 8, 781: 8, 786: 8, 790: 8, 792: 8, 797: 8, 798: 8, 800: 8, 801: 8, 802: 8, 803: 8, 812: 8, 813: 8, 814: 8, 815: 8, 827: 8, 828: 8, 829: 8, 833: 8, 834: 8, 835: 8, 836: 8, 847: 8, 854: 8, 860: 8, 863: 8, 878: 8, 879: 8, 906: 8, 940: 8, 941: 8, 944: 8, 951: 8, 973: 8, 985: 8, 1004: 8, 1020: 8, 1023: 8, 1028: 8, 1031: 8, 1037: 8, 1038: 8, 1040: 8, 1048: 8, 1052: 8, 1058: 8, 1074: 8, 1076: 8, 1097: 8, 1098: 8, 1141: 8, 1163: 8, 1178: 8, 1189: 8, 1193: 8, 1215: 8, 1246: 8, 1273: 8, 1274: 8, 1297: 8, 1298: 8, 1319: 8, 1322: 8, 1337: 8, 1338: 8
+  }],
+  CAR.BYD_SONG_PLUS_DMI_22: [{
+    85: 8, 140: 8, 213: 8, 256: 8, 257: 8, 258: 8, 259: 8, 260: 8, 261: 8, 262: 8, 263: 8, 264: 8, 265: 8, 266: 8, 269: 8, 270: 8, 287: 5, 289: 8, 290: 8, 291: 8, 300: 8, 301: 8, 307: 8, 309: 8, 337: 8, 356: 8, 371: 8, 418: 8, 450: 8, 496: 8, 522: 8, 525: 8, 527: 8, 536: 8, 537: 8, 544: 8, 546: 8, 547: 8, 575: 8, 576: 8, 577: 8, 578: 8, 588: 8, 593: 8, 629: 8, 635: 8, 638: 8, 660: 8, 681: 8, 694: 8, 703: 8, 724: 8, 733: 8, 748: 8, 769: 8, 770: 8, 781: 8, 786: 8, 790: 8, 792: 8, 797: 8, 798: 8, 800: 8, 801: 8, 802: 8, 803: 8, 812: 8, 813: 8, 814: 8, 815: 8, 827: 8, 828: 8, 829: 8, 832: 8, 833: 8, 834: 8, 835: 8, 836: 8, 838: 8, 839: 8, 841: 8, 842: 8, 847: 8, 848: 8, 849: 8, 850: 8, 851: 8, 852: 8, 854: 8, 860: 8, 863: 8, 878: 8, 879: 8, 896: 8, 897: 8, 898: 8, 899: 8, 900: 8, 901: 8, 902: 8, 903: 8, 904: 8, 905: 8, 906: 8, 907: 8, 908: 8, 909: 8, 910: 8, 911: 8, 912: 8, 913: 8, 914: 8, 915: 8, 916: 8, 917: 8, 918: 8, 919: 8, 940: 8, 941: 8, 944: 8, 951: 8, 965: 8, 968: 8, 969: 8, 970: 8, 971: 8, 972: 8, 973: 8, 974: 8, 975: 8, 976: 8, 977: 8, 978: 8, 979: 8, 980: 8, 981: 8, 982: 8, 983: 8, 984: 8, 985: 8, 986: 8, 987: 8, 988: 8, 989: 8, 990: 8, 991: 8, 992: 8, 993: 8, 994: 8, 995: 8, 996: 8, 997: 8, 998: 8, 999: 8, 1000: 8, 1001: 8, 1002: 8, 1003: 8, 1004: 8, 1005: 8, 1006: 8, 1007: 8, 1008: 8, 1009: 8, 1010: 8, 1011: 8, 1012: 8, 1013: 8, 1014: 8, 1015: 8, 1016: 8, 1017: 8, 1018: 8, 1019: 8, 1020: 8, 1021: 8, 1022: 8, 1023: 8, 1028: 8, 1031: 8, 1037: 8, 1038: 8, 1040: 8, 1048: 8, 1052: 8, 1058: 8, 1074: 8, 1076: 8, 1097: 8, 1098: 8, 1141: 8, 1163: 8, 1178: 8, 1189: 8, 1193: 8, 1215: 8, 1246: 8, 1273: 8, 1274: 8, 1278: 8, 1297: 8, 1298: 8, 1337: 8, 1338: 8, 1385: 8
+  }],
+  CAR.BYD_SONG_PLUS_DMI_23: [{
+    85: 8, 140: 8, 213: 8, 269: 8, 270: 8, 287: 5, 289: 8, 290: 8, 291: 8, 300: 8, 301: 8, 307: 8, 337: 8, 352: 8, 353: 8, 356: 8, 357: 8, 360: 8, 361: 8, 364: 8, 368: 8, 369: 8, 370: 8, 371: 8, 372: 8, 373: 8, 374: 8, 376: 8, 377: 8, 378: 8, 380: 8, 381: 8, 382: 8, 384: 8, 385: 8, 386: 8, 388: 8, 389: 8, 390: 8, 392: 8, 393: 8, 394: 8, 396: 8, 397: 8, 398: 8, 400: 8, 401: 8, 402: 8, 404: 8, 405: 8, 406: 8, 408: 8, 409: 8, 410: 8, 412: 8, 413: 8, 414: 8, 416: 8, 417: 8, 418: 8, 420: 8, 421: 8, 422: 8, 424: 8, 425: 8, 426: 8, 427: 8, 428: 8, 429: 8, 430: 8, 432: 8, 433: 8, 434: 8, 436: 8, 437: 8, 438: 8, 440: 8, 441: 8, 442: 8, 444: 8, 445: 8, 446: 8, 448: 8, 449: 8, 450: 8, 452: 8, 453: 8, 454: 8, 456: 8, 457: 8, 458: 8, 460: 8, 461: 8, 462: 8, 464: 8, 465: 8, 466: 8, 468: 8, 469: 8, 470: 8, 472: 8, 473: 8, 474: 8, 476: 8, 477: 8, 478: 8, 480: 8, 481: 8, 483: 8, 484: 8, 485: 8, 486: 8, 488: 8, 489: 8, 490: 8, 492: 8, 493: 8, 494: 8, 496: 8, 522: 8, 525: 8, 527: 8, 536: 8, 537: 8, 544: 8, 546: 8, 547: 8, 575: 8, 576: 8, 577: 8, 578: 8, 588: 8, 593: 8, 629: 8, 660: 8, 681: 8, 694: 8, 703: 8, 724: 8, 748: 8, 781: 8, 786: 8, 790: 8, 792: 8, 797: 8, 798: 8, 800: 8, 801: 8, 802: 8, 803: 8, 812: 8, 813: 8, 814: 8, 815: 8, 833: 8, 834: 8, 835: 8, 836: 8, 843: 8, 847: 8, 854: 8, 860: 8, 863: 8, 878: 8, 879: 8, 884: 8, 906: 8, 940: 8, 941: 8, 944: 8, 951: 8, 965: 8, 973: 8, 985: 8, 1004: 8, 1020: 8, 1023: 8, 1028: 8, 1031: 8, 1037: 8, 1038: 8, 1040: 8, 1048: 8, 1052: 8, 1058: 8, 1074: 8, 1076: 8, 1097: 8, 1098: 8, 1141: 8, 1163: 8, 1169: 8, 1178: 8, 1189: 8, 1193: 8, 1215: 8, 1246: 8, 1273: 8, 1274: 8, 1278: 8, 1297: 8, 1298: 8, 1337: 8, 1338: 8
+  }],
+  CAR.BYD_SONG_PRO_DMI_22: [{
+    85: 8, 140: 8, 213: 8, 269: 8, 270: 8, 287: 5, 289: 8, 290: 8, 291: 8, 300: 8, 301: 8, 307: 8, 337: 8, 356: 8, 371: 8, 418: 8, 450: 8, 496: 8, 522: 8, 525: 8, 527: 8, 536: 8, 537: 8, 544: 8, 546: 8, 547: 8, 576: 8, 577: 8, 578: 8, 588: 8, 593: 8, 629: 8, 638: 8, 660: 8, 681: 8, 694: 8, 703: 8, 724: 8, 748: 8, 781: 8, 786: 8, 790: 8, 792: 8, 797: 8, 798: 8, 800: 8, 801: 8, 802: 8, 803: 8, 812: 8, 813: 8, 814: 8, 815: 8, 827: 8, 828: 8, 829: 8, 833: 8, 834: 8, 835: 8, 836: 8, 843: 8, 847: 8, 854: 8, 860: 8, 863: 8, 878: 8, 879: 8, 884: 8, 906: 8, 944: 8, 951: 8, 965: 8, 973: 8, 985: 8, 1004: 8, 1020: 8, 1023: 8, 1028: 8, 1031: 8, 1037: 8, 1038: 8, 1040: 8, 1048: 8, 1052: 8, 1058: 8, 1074: 8, 1076: 8, 1097: 8, 1098: 8, 1141: 8, 1163: 8, 1178: 8, 1189: 8, 1193: 8, 1215: 8, 1246: 8, 1273: 8, 1274: 8, 1278: 8, 1297: 8, 1298: 8
+  }],
+  CAR.BYD_QIN_PLUS_DMI_23: [{
+    85: 8, 140: 8, 213: 8, 234: 8, 235: 8, 269: 8, 270: 8, 287: 5, 289: 8, 290: 8, 291: 8, 300: 8, 301: 8, 307: 8, 337: 8, 371: 8, 450: 8, 455: 8, 496: 8, 522: 8, 525: 8, 527: 8, 536: 8, 537: 8, 544: 8, 546: 8, 547: 8, 575: 8, 576: 8, 577: 8, 578: 8, 588: 8, 593: 8, 629: 8, 635: 8, 638: 8, 660: 8, 681: 8, 694: 8, 703: 8, 724: 8, 733: 8, 748: 8, 781: 8, 786: 8, 797: 8, 798: 8, 800: 8, 801: 8, 802: 8, 803: 8, 813: 8, 814: 8, 815: 8, 833: 8, 834: 8, 835: 8, 836: 8, 847: 8, 854: 8, 860: 8, 878: 8, 906: 8, 944: 8, 951: 8, 965: 8, 973: 8, 985: 8, 1004: 8, 1023: 8, 1028: 8, 1031: 8, 1037: 8, 1038: 8, 1040: 8, 1052: 8, 1058: 8, 1074: 8, 1076: 8, 1097: 8, 1098: 8, 1141: 8, 1163: 8, 1169: 8, 1178: 8, 1189: 8, 1193: 8, 1211: 8, 1215: 8, 1226: 8, 1246: 8, 1273: 8, 1274: 8, 1278: 8, 1297: 8
+  }],
+  CAR.BYD_YUAN_PLUS_DMI_22: [{
+    85: 8, 140: 8, 213: 8, 287: 5, 289: 8, 290: 8, 291: 8, 301: 8, 307: 8, 309: 8, 324: 8, 337: 8, 371: 8, 450: 8, 496: 8, 522: 8, 536: 8, 537: 8, 544: 8, 546: 8, 547: 8, 575: 8, 576: 8, 577: 8, 578: 8, 588: 8, 629: 8, 639: 8, 660: 8, 694: 8, 724: 8, 748: 8, 786: 8, 790: 8, 792: 8, 797: 8, 798: 8, 800: 8, 801: 8, 802: 8, 803: 8, 812: 8, 813: 8, 814: 8, 815: 8, 833: 8, 834: 8, 835: 8, 836: 8, 843: 8, 847: 8, 848: 8, 854: 8, 860: 8, 863: 8, 879: 8, 884: 8, 906: 8, 944: 8, 951: 8, 965: 8, 973: 8, 985: 8, 1004: 8, 1020: 8, 1023: 8, 1028: 8, 1031: 8, 1037: 8, 1040: 8, 1048: 8, 1052: 8, 1058: 8, 1074: 8, 1076: 8, 1098: 8, 1141: 8, 1169: 8, 1178: 8, 1184: 8, 1189: 8, 1192: 8, 1193: 8, 1211: 8, 1215: 8, 1246: 8, 1274: 8, 1278: 8, 1297: 8, 1319: 8, 1322: 8
+  }],
+}
+
+#Todo: Get a byd VDS to see how fw could be queried. Currently added just for preventing ruffs error.
+FW_VERSIONS = {
+  CAR.BYD_HAN_DM_20: {
+    (Ecu.eps, 0x700, None): [
+      b'DUMMYDATA',
+    ],
+  },
+}
\ No newline at end of file
diff --git a/opendbc/car/byd/interface.py b/opendbc/car/byd/interface.py
new file mode 100755
index 00000000..1c0401b2
--- /dev/null
+++ b/opendbc/car/byd/interface.py
@@ -0,0 +1,133 @@
+#!/usr/bin/env python3
+from math import exp
+
+from opendbc.car import get_safety_config, get_friction, structs
+from opendbc.car.common.conversions import Conversions as CV
+from opendbc.car.interfaces import CarInterfaceBase, TorqueFromLateralAccelCallbackType, FRICTION_THRESHOLD, LatControlInputs
+from opendbc.car.byd.values import CAR, CanBus, BydSafetyFlags, MPC_ACC_CAR, TORQUE_LAT_CAR, EXP_LONG_CAR, \
+                                PLATFORM_HANTANG_DMEV, PLATFORM_TANG_DMI, PLATFORM_SONG_PLUS_DMI, PLATFORM_QIN_PLUS_DMI, PLATFORM_YUAN_PLUS_DMI_ATTO3
+from opendbc.car.byd.carcontroller import CarController
+from opendbc.car.byd.carstate import CarState
+from opendbc.car.byd.radar_interface import RadarInterface
+
+ButtonType = structs.CarState.ButtonEvent.Type
+GearShifter = structs.CarState.GearShifter
+TransmissionType = structs.CarParams.TransmissionType
+NetworkLocation = structs.CarParams.NetworkLocation
+
+NON_LINEAR_TORQUE_PARAMS = {
+  CAR.BYD_HAN_DM_20: [1.807, 1.674, 0.04],
+  CAR.BYD_HAN_EV_20: [1.807, 1.674, 0.04]
+}
+
+class CarInterface(CarInterfaceBase):
+    CarState = CarState
+    CarController = CarController
+    RadarInterface = RadarInterface
+
+    def torque_from_lateral_accel_siglin(self, latcontrol_inputs: LatControlInputs, torque_params: structs.CarParams.LateralTorqueTuning,
+                                    lateral_accel_error: float, lateral_accel_deadzone: float, friction_compensation: bool, gravity_adjusted: bool) -> float:
+        friction = get_friction(lateral_accel_error, lateral_accel_deadzone, FRICTION_THRESHOLD, torque_params, friction_compensation)
+
+        def sig(val):
+            # https://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick
+            if val >= 0:
+                return 1 / (1 + exp(-val)) - 0.5
+            else:
+                z = exp(val)
+                return z / (1 + z) - 0.5
+
+        # The "lat_accel vs torque" relationship is assumed to be the sum of "sigmoid + linear" curves
+        # An important thing to consider is that the slope at 0 should be > 0 (ideally >1)
+        # This has big effect on the stability about 0 (noise when going straight)
+        non_linear_torque_params = NON_LINEAR_TORQUE_PARAMS.get(self.CP.carFingerprint)
+        assert non_linear_torque_params, "The params are not defined"
+        a, b, c = non_linear_torque_params
+        steer_torque = (sig(latcontrol_inputs.lateral_acceleration * a) * b) + (latcontrol_inputs.lateral_acceleration * c)
+        return float(steer_torque) + friction
+
+    def torque_from_lateral_accel(self) -> TorqueFromLateralAccelCallbackType:
+        if self.CP.carFingerprint in NON_LINEAR_TORQUE_PARAMS:
+            return self.torque_from_lateral_accel_siglin
+        else:
+            return self.torque_from_lateral_accel_linear
+
+    @staticmethod
+    def _get_params(ret: structs.CarParams, candidate, fingerprint, car_fw, experimental_long, docs) -> structs.CarParams: # type: ignore
+        ret.brand = "byd"
+        ret.safetyConfigs = [get_safety_config(structs.CarParams.SafetyModel.byd)]
+
+        ret.dashcamOnly = False
+        #disable simple pt radar due to mpc solver issue in official OP. It works with carrot/sunny/forg.
+        ret.radarUnavailable = True #candidate not in PT_RADAR_CAR
+
+
+        ret.minEnableSpeed = -1.
+        ret.enableBsm = 0x418 in fingerprint[CanBus.ESC]
+        ret.transmissionType = TransmissionType.direct
+
+        ret.minEnableSpeed = -1.
+        ret.minSteerSpeed = 0.1 * CV.KPH_TO_MS
+
+        ret.steerActuatorDelay = 0.05
+        ret.steerLimitTimer = 0.4
+
+        if candidate in PLATFORM_HANTANG_DMEV:
+            ret.safetyConfigs[0].safetyParam |= BydSafetyFlags.HAN_TANG_DMEV.value
+        elif candidate in PLATFORM_TANG_DMI:
+            ret.safetyConfigs[0].safetyParam |= BydSafetyFlags.TANG_DMI.value
+        elif candidate in PLATFORM_SONG_PLUS_DMI:
+                    ret.safetyConfigs[0].safetyParam |= BydSafetyFlags.SONG_PLUS_DMI.value
+        elif candidate in PLATFORM_QIN_PLUS_DMI:
+                    ret.safetyConfigs[0].safetyParam |= BydSafetyFlags.QIN_PLUS_DMI.value
+        elif candidate in PLATFORM_YUAN_PLUS_DMI_ATTO3:
+                    ret.safetyConfigs[0].safetyParam |= BydSafetyFlags.YUAN_PLUS_DMI_ATTO3.value
+
+        if candidate in MPC_ACC_CAR:
+            ret.networkLocation = NetworkLocation.fwdCamera
+
+        use_torque_lat = candidate in TORQUE_LAT_CAR
+
+        if use_torque_lat:
+            CarInterfaceBase.configure_torque_tune(candidate, ret.lateralTuning)
+        else:
+            ret.lateralTuning.init('pid')
+            ret.lateralTuning.pid.kpBP, ret.lateralTuning.pid.kiBP = [[8.3 , 27.8], [8.3 , 27.8]]
+            ret.lateralTuning.pid.kpV, ret.lateralTuning.pid.kiV   = [[0.6 ,  0.3], [0.2 ,  0.1]]
+            ret.lateralTuning.pid.kf = 0.000072
+
+        use_experimental_long = candidate in EXP_LONG_CAR
+
+        ret.experimentalLongitudinalAvailable = use_experimental_long
+        ret.openpilotLongitudinalControl = experimental_long and ret.experimentalLongitudinalAvailable
+
+        ret.longitudinalTuning.kpBP, ret.longitudinalTuning.kiBP = [[0.],  [0.]]
+        ret.longitudinalTuning.kpV,  ret.longitudinalTuning.kiV  = [[1.5], [0.3]]
+
+        # model specific parameters
+        # Todo: Developers please fill or add more models.
+        if candidate in (CAR.BYD_HAN_DM_20, CAR.BYD_HAN_EV_20, CAR.BYD_TANG_DM):
+            ret.minSteerSpeed = 0
+            ret.autoResumeSng = True
+            ret.startingState = True
+            ret.startAccel = 0.8
+            ret.stopAccel = -0.5
+            ret.vEgoStarting = 0.2 * CV.KPH_TO_MS
+            ret.vEgoStopping = 0.1 * CV.KPH_TO_MS
+            ret.longitudinalActuatorDelay = 0.5
+        else:
+            ret.dashcamOnly = True
+
+        return ret
+
+
+# byd tuning suggestions
+# torque mode (linear):
+#   -Start with P = 1.0 and I = 0, FRICTION = 0, change the LAT_ACCEL_FACTOR until
+#    vehicle can just about to go thought a medium curve at medium speed(say 50kph)
+#   -Find a straight road and tune FRICTION until car stay in same position of lane,
+#    don't worry if car hugs to left or right.
+#   -I = 0.1 (default) then try. Keep tuning all values until you get a good enough
+#    result. Commaai's PI loop have a funny anti-wind up method.
+#   -Add the steering angle speed (angle slew rate) to stop the control loop from
+#    tuning wheel too sharp.
\ No newline at end of file
diff --git a/opendbc/car/byd/radar_interface.py b/opendbc/car/byd/radar_interface.py
new file mode 100755
index 00000000..74fc8051
--- /dev/null
+++ b/opendbc/car/byd/radar_interface.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+from opendbc.car.interfaces import RadarInterfaceBase
+from opendbc.car import Bus, structs
+from opendbc.can.parser import CANParser
+from opendbc.car.byd.values import DBC, CanBus
+
+class RadarInterface(RadarInterfaceBase):
+  def __init__(self, CP):
+    super().__init__(CP)
+
+    if CP.radarUnavailable:
+      self.rcp = None
+    else:
+      messages = [('RADAR_MRR', 60)]
+      self.rcp = CANParser(DBC[CP.carFingerprint][Bus.pt], messages, CanBus.MPC)
+      self.trigger_msg = 0x374
+
+    self.updated_messages = set()
+
+  def update(self, can_strings):
+    if self.rcp is None:
+      return super().update(None)
+
+    values = self.rcp.update_strings(can_strings)
+    self.updated_messages.update(values)
+
+    if self.trigger_msg not in self.updated_messages:
+      return None
+
+    ret = structs.RadarData()
+
+    #if not self.rcp.can_valid:
+    #  ret.errors.canError = True
+
+    msg_mrr = self.rcp.vl['RADAR_MRR']
+    msg_id = msg_mrr['TargetID'] #1:left, 2:front, 3:right
+    if msg_id == 2:
+      longdist = msg_mrr['LongDist']
+      isvalid = longdist > 0 or bool(msg_mrr['IsValid'])
+
+      if(msg_id not in self.pts):
+        self.pts[msg_id] = structs.RadarData.RadarPoint()
+        self.pts[msg_id].trackId = msg_id
+
+      self.pts[msg_id].dRel = longdist if isvalid else 255
+      self.pts[msg_id].yRel =  msg_mrr['LatDist'] if isvalid else 0
+      self.pts[msg_id].vRel = float('nan')
+      self.pts[msg_id].aRel = float('nan')
+      self.pts[msg_id].yvRel = float('nan')
+      self.pts[msg_id].measured = True
+
+    ret.points = list(self.pts.values())
+    self.updated_messages.clear()
+    return ret
diff --git a/opendbc/car/byd/values.py b/opendbc/car/byd/values.py
new file mode 100755
index 00000000..83dcf420
--- /dev/null
+++ b/opendbc/car/byd/values.py
@@ -0,0 +1,154 @@
+from dataclasses import dataclass, field
+from enum import IntFlag
+from opendbc.car import Bus, DbcDict, PlatformConfig, Platforms, CarSpecs
+from opendbc.car.structs import CarParams
+from opendbc.car.docs_definitions import CarHarness, CarDocs, CarParts
+from opendbc.car.fw_query_definitions import FwQueryConfig, Request, StdQueries
+
+Ecu = CarParams.Ecu
+
+class CarControllerParams:
+  STEER_MAX = 300
+  STEER_DELTA_UP = 7
+  STEER_DELTA_DOWN = 10
+
+  STEER_DRIVER_ALLOWANCE = 68
+  STEER_DRIVER_MULTIPLIER = 3
+  STEER_DRIVER_FACTOR = 1
+  STEER_ERROR_MAX = 50
+
+  STEER_STEP = 2  #100/2=50hz
+  STEER_SOFTSTART_STEP = 6 # 20ms(50Hz) * 300 / 6 = 1000ms. This means the clip ceiling will be increased to 300 in 1000ms
+
+  ACC_STEP = 2    #50hz
+
+  ACCEL_MAX = 2.0
+  ACCEL_MIN = -3.5
+
+  K_DASHSPEED = 0.0719088 #convert pulse to kph
+
+  USE_STEERING_SPEED_LIMITER = False
+
+  # op long control
+  K_accel_jerk_upper = 0.1
+  K_accel_jerk_lower = 0.5
+  K_jerk_xp =            [   4,   10,   20,   40,   80]  # meters
+  K_jerk_base_lower_fp = [-2.3, -1.8, -1.4, -1.0, -0.4]
+  K_jerk_base_upper_fp = [ 0.8,  0.7,  0.6,  0.3,  0.2]
+
+  def __init__(self, CP):
+    pass
+
+#FD to be added later
+class BydSafetyFlags(IntFlag):
+  HAN_TANG_DMEV = 0x1 #pre 2021 models with veoneer mpc/radar solution
+  TANG_DMI = 0x2 #note tang dmi is not tang dm
+  SONG_PLUS_DMI = 0x4 #note song pro is similar but not song dmi
+  QIN_PLUS_DMI = 0x8
+  YUAN_PLUS_DMI_ATTO3 = 0x10 #yuan plus is atto3
+
+
+@dataclass
+class BydCarDocs(CarDocs):
+  package: str = "All"
+  car_parts: CarParts = field(default_factory=CarParts.common([CarHarness.custom]))
+  #todo add docs and harness info
+
+@dataclass
+class BydPlatformConfig(PlatformConfig):
+  dbc_dict: DbcDict = field(default_factory=lambda: {Bus.pt: "byd_han_dmev_2020"})
+  #todo add dbc for other models
+
+class CAR(Platforms):
+  BYD_HAN_DM_20 = BydPlatformConfig(
+    [BydCarDocs("BYD HAN DM 20")],
+    CarSpecs(mass=2080., wheelbase=2.920, steerRatio=16.8, centerToFrontRatio=0.44, tireStiffnessFactor=1.0),
+  )
+  BYD_HAN_EV_20 = BydPlatformConfig(
+    [BydCarDocs("BYD HAN EV 20")],
+    CarSpecs(mass=2100., wheelbase=2.959, steerRatio=16.8, centerToFrontRatio=0.44, tireStiffnessFactor=1.0),
+  )
+
+  #The following parameters are likely be incorrect, developers please fill and fix them.
+
+  BYD_TANG_DM = BydPlatformConfig(
+    [BydCarDocs("BYD TANG DM")],
+    CarSpecs(mass=2250., wheelbase=2.820, steerRatio=15.0, centerToFrontRatio=0.44, tireStiffnessFactor=1.0),
+  )
+
+  BYD_TANG_DMI_21 = BydPlatformConfig(
+    [BydCarDocs("BYD TANG DMI 21")],
+    CarSpecs(mass=2153., wheelbase=2.820, steerRatio=15.0, centerToFrontRatio=0.44, tireStiffnessFactor=1.0),
+  )
+
+  BYD_SONG_PLUS_DMI_21 = BydPlatformConfig(
+    [BydCarDocs("BYD SONG PLUS DMI 21")],
+    CarSpecs(mass=1785., wheelbase=2.765, steerRatio=15.0, centerToFrontRatio=0.44, tireStiffnessFactor=1.0),
+  )
+
+  BYD_SONG_PLUS_DMI_22 = BydPlatformConfig(
+    [BydCarDocs("BYD SONG PLUS DMI 22")],
+    CarSpecs(mass=1785., wheelbase=2.765, steerRatio=15.0, centerToFrontRatio=0.44, tireStiffnessFactor=1.0),
+  )
+
+  BYD_SONG_PLUS_DMI_23 = BydPlatformConfig(
+    [BydCarDocs("BYD SONG PLUS DMI 23")],
+    CarSpecs(mass=1785., wheelbase=2.765, steerRatio=15.0, centerToFrontRatio=0.44, tireStiffnessFactor=1.0),
+  )
+
+  BYD_SONG_PRO_DMI_22 = BydPlatformConfig(
+    [BydCarDocs("BYD SONG PRO DMI 22")],
+    CarSpecs(mass=1670., wheelbase=2.712, steerRatio=15.0, centerToFrontRatio=0.44, tireStiffnessFactor=1.0),
+  )
+
+  BYD_QIN_PLUS_DMI_23 = BydPlatformConfig(
+    [BydCarDocs("BYD QIN PLUS DMI 23")],
+    CarSpecs(mass=1580., wheelbase=2.718, steerRatio=15.0, centerToFrontRatio=0.44, tireStiffnessFactor=1.0),
+  )
+
+  BYD_YUAN_PLUS_DMI_22 = BydPlatformConfig(
+    [BydCarDocs("BYD YUAN PLUS DMI 22")],
+    CarSpecs(mass=1625., wheelbase=2.720, steerRatio=15.0, centerToFrontRatio=0.44, tireStiffnessFactor=1.0),
+  )
+
+
+class LKASConfig:
+  DISABLE = 0
+  ALARM = 1
+  LKA = 2
+  ALARM_AND_LKA = 3
+
+class CanBus:
+  ESC = 0
+  MRR = 1
+  MPC = 2
+
+FW_QUERY_CONFIG = FwQueryConfig(
+  requests=[
+    Request(
+      [StdQueries.MANUFACTURER_SOFTWARE_VERSION_REQUEST],
+      [StdQueries.MANUFACTURER_SOFTWARE_VERSION_RESPONSE],
+      bus=CanBus.ESC,
+    ),
+  ],
+)
+
+PLATFORM_HANTANG_DMEV = {CAR.BYD_HAN_DM_20, CAR.BYD_HAN_EV_20, CAR.BYD_TANG_DM}
+PLATFORM_TANG_DMI = {CAR.BYD_TANG_DMI_21}
+PLATFORM_SONG_PLUS_DMI = {CAR.BYD_SONG_PLUS_DMI_21, CAR.BYD_SONG_PLUS_DMI_22, CAR.BYD_SONG_PLUS_DMI_23, CAR.BYD_SONG_PRO_DMI_22}
+PLATFORM_QIN_PLUS_DMI = {CAR.BYD_QIN_PLUS_DMI_23}
+PLATFORM_YUAN_PLUS_DMI_ATTO3 = {CAR.BYD_YUAN_PLUS_DMI_22}
+
+# power train canbus is located and accessible in in MPC connector
+MPC_ACC_CAR = {CAR.BYD_HAN_DM_20, CAR.BYD_HAN_EV_20, CAR.BYD_TANG_DM}
+
+# power train canbus contains mrr radar info
+PT_RADAR_CAR = {CAR.BYD_HAN_DM_20, CAR.BYD_HAN_EV_20, CAR.BYD_TANG_DM}
+
+# use torque lat control, otherwise use angle mode
+TORQUE_LAT_CAR = {CAR.BYD_HAN_DM_20, CAR.BYD_HAN_EV_20, CAR.BYD_TANG_DM}
+
+# use experimental long mode
+EXP_LONG_CAR = {CAR.BYD_HAN_DM_20, CAR.BYD_HAN_EV_20, CAR.BYD_TANG_DM}
+
+DBC = CAR.create_dbc_map()
diff --git a/opendbc/car/car.capnp b/opendbc/car/car.capnp
index 5c5a7d68..84a82a34 100644
--- a/opendbc/car/car.capnp
+++ b/opendbc/car/car.capnp
@@ -637,6 +637,7 @@ struct CarParams {
     fcaGiorgio @32;
     rivian @33;
     volkswagenMeb @34;
+    byd @35;
   }
 
   enum SteerControlType {
diff --git a/opendbc/car/fingerprints.py b/opendbc/car/fingerprints.py
index d9ced619..d4614574 100644
--- a/opendbc/car/fingerprints.py
+++ b/opendbc/car/fingerprints.py
@@ -1,5 +1,6 @@
 from opendbc.car.interfaces import get_interface_attr
 from opendbc.car.body.values import CAR as BODY
+from opendbc.car.byd.values import CAR as BYD
 from opendbc.car.chrysler.values import CAR as CHRYSLER
 from opendbc.car.ford.values import CAR as FORD
 from opendbc.car.gm.values import CAR as GM
@@ -59,6 +60,8 @@ MIGRATION = {
   "ACURA RDX 2018 ACURAWATCH PLUS": HONDA.ACURA_RDX,
   "ACURA RDX 2020 TECH": HONDA.ACURA_RDX_3G,
   "AUDI A3": VW.AUDI_A3_MK3,
+  "BYD HAN DM 20": BYD.BYD_HAN_DM_20,
+  "BYD HAN EV 20": BYD.BYD_HAN_EV_20,
   "HONDA ACCORD 2018 HYBRID TOURING": HONDA.HONDA_ACCORD,
   "HONDA ACCORD 1.5T 2018": HONDA.HONDA_ACCORD,
   "HONDA ACCORD 2018 LX 1.5T": HONDA.HONDA_ACCORD,
diff --git a/opendbc/car/fw_versions.py b/opendbc/car/fw_versions.py
index 09d83b52..2125f590 100644
--- a/opendbc/car/fw_versions.py
+++ b/opendbc/car/fw_versions.py
@@ -236,7 +236,8 @@ def get_fw_versions_ordered(can_recv: CanRecvCallable, can_send: CanSendCallable
 
   # Sort brands by number of matching ECUs first, then percentage of matching ECUs in the database
   # This allows brands with only one ECU to be queried first (e.g. Tesla)
-  for brand in sorted(brand_matches, key=lambda b: (brand_matches[b].count(True), brand_matches[b].count(True) / len(brand_matches[b])), reverse=True):
+  for brand in sorted(brand_matches, key=lambda b: (brand_matches[b].count(True), \
+                                                    brand_matches[b].count(True) / (len(brand_matches[b]) if len(brand_matches[b]) > 0 else 1)), reverse=True):
     # Skip this brand if there are no matching present ECUs
     if True not in brand_matches[brand]:
       continue
diff --git a/opendbc/car/tests/routes.py b/opendbc/car/tests/routes.py
index d582ec6e..d0fe5d82 100644
--- a/opendbc/car/tests/routes.py
+++ b/opendbc/car/tests/routes.py
@@ -15,6 +15,7 @@ from opendbc.car.toyota.values import CAR as TOYOTA
 from opendbc.car.values import Platform
 from opendbc.car.volkswagen.values import CAR as VOLKSWAGEN
 from opendbc.car.body.values import CAR as COMMA
+from opendbc.car.byd.values import CAR as BYD
 
 # FIXME: add routes for these cars
 non_tested_cars = [
@@ -28,6 +29,16 @@ non_tested_cars = [
   SUBARU.SUBARU_FORESTER_HYBRID,
   TESLA.TESLA_MODEL_3,
   TESLA.TESLA_MODEL_Y,
+  BYD.BYD_HAN_DM_20, #byd routes to be added later with official device
+  BYD.BYD_HAN_EV_20,
+  BYD.BYD_QIN_PLUS_DMI_23,
+  BYD.BYD_SONG_PLUS_DMI_21,
+  BYD.BYD_SONG_PLUS_DMI_22,
+  BYD.BYD_SONG_PLUS_DMI_23,
+  BYD.BYD_SONG_PRO_DMI_22,
+  BYD.BYD_TANG_DM,
+  BYD.BYD_TANG_DMI_21,
+  BYD.BYD_YUAN_PLUS_DMI_22
 ]
 
 
diff --git a/opendbc/car/tests/test_fw_fingerprint.py b/opendbc/car/tests/test_fw_fingerprint.py
index 58d2ba65..323bd533 100644
--- a/opendbc/car/tests/test_fw_fingerprint.py
+++ b/opendbc/car/tests/test_fw_fingerprint.py
@@ -260,7 +260,7 @@ class TestFwFingerprintTiming:
         print(f'get_vin {name} case, query time={self.total_time / self.N} seconds')
 
   def test_fw_query_timing(self, subtests, mocker):
-    total_ref_time = {1: 7.3, 2: 7.9}
+    total_ref_time = {1: 7.4, 2: 8.0}
     brand_ref_times = {
       1: {
         'gm': 1.0,
@@ -276,10 +276,12 @@ class TestFwFingerprintTiming:
         'toyota': 0.7,
         'volkswagen': 0.65,
         'rivian': 0.3,
+        'byd': 0.1, #todo: verify this value in official device
       },
       2: {
         'ford': 1.6,
         'hyundai': 1.15,
+        'byd': 0.1,
       }
     }
 
diff --git a/opendbc/car/torque_data/params.toml b/opendbc/car/torque_data/params.toml
index 4bb8d45c..c39e44c8 100644
--- a/opendbc/car/torque_data/params.toml
+++ b/opendbc/car/torque_data/params.toml
@@ -4,6 +4,16 @@ legend = ["LAT_ACCEL_FACTOR", "MAX_LAT_ACCEL_MEASURED", "FRICTION"]
 "ACURA_RDX_3G" = [1.4314459806646749, 0.33874701282109954, 0.18048847083897598]
 "AUDI_A3_MK3" = [1.5122414863077502, 1.7443517531719404, 0.15194151892450905]
 "AUDI_Q3_MK2" = [1.4439223359448605, 1.2254955789112076, 0.1413798895978097]
+"BYD_HAN_DM_20" = [2.2, 2.5, 0.145]
+"BYD_HAN_EV_20" = [2.2, 2.5, 0.145]
+"BYD_TANG_DM" = [2.2, 2.5, 0.145]
+"BYD_TANG_DMI_21" = [2.2, 2.5, 0.145]
+"BYD_SONG_PLUS_DMI_21" = [2.2, 2.5, 0.145]
+"BYD_SONG_PLUS_DMI_22" = [2.2, 2.5, 0.145]
+"BYD_SONG_PLUS_DMI_23" = [2.2, 2.5, 0.145]
+"BYD_SONG_PRO_DMI_22" = [2.2, 2.5, 0.145]
+"BYD_QIN_PLUS_DMI_23" = [2.2, 2.5, 0.145]
+"BYD_YUAN_PLUS_DMI_22" = [2.2, 2.5, 0.145]
 "CHEVROLET_VOLT" = [1.5961527626411784, 1.8422651988094612, 0.1572393918005158]
 "CHRYSLER_PACIFICA_2018" = [2.07140, 1.3366521181047952, 0.13776367250652022]
 "CHRYSLER_PACIFICA_2020" = [1.86206, 1.509076559398423, 0.14328246159386085]
diff --git a/opendbc/car/values.py b/opendbc/car/values.py
index cd7dbb95..cb3a638d 100644
--- a/opendbc/car/values.py
+++ b/opendbc/car/values.py
@@ -1,5 +1,6 @@
 from typing import get_args
 from opendbc.car.body.values import CAR as BODY
+from opendbc.car.byd.values import CAR as BYD
 from opendbc.car.chrysler.values import CAR as CHRYSLER
 from opendbc.car.ford.values import CAR as FORD
 from opendbc.car.gm.values import CAR as GM
@@ -14,7 +15,7 @@ from opendbc.car.tesla.values import CAR as TESLA
 from opendbc.car.toyota.values import CAR as TOYOTA
 from opendbc.car.volkswagen.values import CAR as VOLKSWAGEN
 
-Platform = BODY | CHRYSLER | FORD | GM | HONDA | HYUNDAI | MAZDA | MOCK | NISSAN | RIVIAN | SUBARU | TESLA | TOYOTA | VOLKSWAGEN
+Platform = BODY | BYD | CHRYSLER | FORD | GM | HONDA | HYUNDAI | MAZDA | MOCK | NISSAN | RIVIAN | SUBARU | TESLA | TOYOTA | VOLKSWAGEN
 BRANDS = get_args(Platform)
 
 PLATFORMS: dict[str, Platform] = {str(platform): platform for brand in BRANDS for platform in brand}
diff --git a/opendbc/dbc/byd_han_dmev_2020.dbc b/opendbc/dbc/byd_han_dmev_2020.dbc
new file mode 100755
index 00000000..8a444c7e
--- /dev/null
+++ b/opendbc/dbc/byd_han_dmev_2020.dbc
@@ -0,0 +1,215 @@
+VERSION ""
+
+
+NS_ :
+	NS_DESC_
+	CM_
+	BA_DEF_
+	BA_
+	VAL_
+	CAT_DEF_
+	CAT_
+	FILTER
+	BA_DEF_DEF_
+	EV_DATA_
+	ENVVAR_DATA_
+	SGTYPE_
+	SGTYPE_VAL_
+	BA_DEF_SGTYPE_
+	BA_SGTYPE_
+	SIG_TYPE_REF_
+	VAL_TABLE_
+	SIG_GROUP_
+	SIG_VALTYPE_
+	SIGTYPE_VALTYPE_
+	BO_TX_BU_
+	BA_DEF_REL_
+	BA_REL_
+	BA_DEF_DEF_REL_
+	BU_SG_REL_
+	BU_EV_REL_
+	BU_BO_REL_
+	SG_MUL_VAL_
+
+BS_:
+
+BU_: XXX
+
+
+BO_ 85 EPB: 8 XXX
+ SG_ EPB_ActiveFlag : 40|1@1+ (1,0) [0|1] "" XXX
+ SG_ CheckSum : 56|8@1+ (1,0) [0|255] "" XXX
+
+BO_ 287 EPS: 5 XXX
+ SG_ SteeringAngle : 0|16@1- (0.1,0) [-450|450] "" XXX
+ SG_ SteeringAngleRate : 16|8@1+ (4,0) [0|1020] "" XXX
+ SG_ Counter : 32|8@1+ (1,0) [0|255] "" XXX
+
+BO_ 289 CARSPEED: 8 XXX
+ SG_ CarDisplaySpeed : 0|12@1+ (1,0) [0|255] "" XXX
+
+BO_ 301 BCM: 8 XXX
+ SG_ FrontLeftDoor : 0|1@0+ (1,0) [0|1] "" XXX
+ SG_ FrontRightDoor : 1|1@0+ (1,0) [0|1] "" XXX
+ SG_ RearLeftDoor : 2|1@0+ (1,0) [0|1] "" XXX
+ SG_ RearRightDoor : 3|1@0+ (1,0) [0|1] "" XXX
+ SG_ BootDoor : 4|1@0+ (1,0) [0|1] "" XXX
+ SG_ DriverSeatBeltFasten : 6|1@0+ (1,0) [0|1] "" XXX
+ SG_ BrakeLight : 8|1@0+ (1,0) [0|1] "" XXX
+ SG_ FrontRightPassengerSeatBelt : 55|1@0+ (1,0) [0|1] "" XXX
+
+BO_ 307 STALKS: 8 XXX
+ SG_ FrontFogLight : 0|1@0+ (1,0) [0|1] "" XXX
+ SG_ LightsOn : 1|1@1+ (1,0) [0|1] "" XXX
+ SG_ HeadLight : 2|1@1+ (1,0) [0|1] "" XXX
+ SG_ FullBeamOn : 3|1@1+ (1,0) [0|1] "" XXX
+ SG_ LeftIndicator : 4|1@0+ (1,0) [0|1] "" XXX
+ SG_ RightIndicator : 5|1@0+ (1,0) [0|1] "" XXX
+ SG_ RearFogLight : 7|1@0+ (1,0) [0|1] "" XXX
+ SG_ TURN_SIGNAL_SWITCH : 36|3@1+ (1,0) [0|7] "" XXX
+ SG_ AutoHeadlight : 40|1@0+ (1,0) [0|1] "" XXX
+ SG_ Heartbeat : 63|4@0+ (1,0) [0|15] "" XXX
+
+BO_ 578 DRIVE_STATE: 8 XXX
+ SG_ ReqThrottle : 30|7@0+ (1,0) [0|127] "" XXX
+ SG_ BrakePressed : 37|1@0+ (1,0) [0|1] "" XXX
+ SG_ Gear : 40|3@1+ (1,0) [0|7] "" XXX
+ SG_ Counter : 55|4@0+ (1,0) [0|15] "" XXX
+ SG_ CheckSum : 56|8@1+ (1,0) [0|255] "" XXX
+
+BO_ 694 DATETIME: 8 XXX
+ SG_ YY : 7|8@0+ (1,0) [0|255] "" XXX
+ SG_ MM : 15|8@0+ (1,0) [0|255] "" XXX
+ SG_ DD : 23|8@0+ (1,0) [0|255] "" XXX
+ SG_ hh : 31|8@0+ (1,0) [0|255] "" XXX
+ SG_ mm : 39|8@0+ (1,0) [0|255] "" XXX
+ SG_ ss : 47|8@0+ (1,0) [0|255] "" XXX
+
+BO_ 790 ACC_MPC_STATE: 8 XXX
+ SG_ AutoFullBeamState : 3|4@0+ (1,0) [0|1] "" XXX
+ SG_ LeftLaneState : 4|2@1+ (1,0) [0|3] "" XXX
+ SG_ LKAS_Config : 6|2@1+ (1,0) [0|3] "" XXX
+ SG_ SETME2_0x1 : 8|2@1+ (1,0) [0|3] "" XXX
+ SG_ ReqHandsOnSteeringWheel : 10|1@1+ (1,0) [0|1] "" XXX
+ SG_ MPC_State : 11|4@1+ (1,0) [0|1] "" XXX
+ SG_ AutoFullBeam_OnOff : 15|1@0+ (1,0) [0|1] "" XXX
+ SG_ LKAS_Output : 16|11@1- (1,0) [-1024|1023] "" XXX
+ SG_ LKAS_ReqPrepare : 27|1@1+ (1,0) [0|1] "" XXX
+ SG_ LKAS_Active : 28|1@1+ (1,0) [0|3] "" XXX
+ SG_ SETME3_0x0 : 29|1@0+ (1,0) [0|1] "" XXX
+ SG_ TrafficSignRecognition_OnOff : 30|1@0+ (1,0) [0|1] "" XXX
+ SG_ SETME4_0x0 : 31|1@0+ (1,0) [0|1] "" XXX
+ SG_ SETME5_0x1 : 32|2@1+ (1,0) [0|3] "" XXX
+ SG_ RightLaneState : 34|2@1+ (1,0) [0|3] "" XXX
+ SG_ LKAS_State : 36|4@1+ (1,0) [0|3] "" XXX
+ SG_ TrafficSignRecognition_Result : 40|8@1+ (5,-5) [-5|1270] "" XXX
+ SG_ LKAS_AlarmType : 49|2@0+ (1,0) [0|3] "" XXX
+ SG_ SETME7_0x3 : 51|2@0+ (1,0) [0|3] "" XXX
+ SG_ Counter : 52|4@1+ (1,0) [0|15] "" XXX
+ SG_ CheckSum : 56|8@1+ (1,0) [0|15] "" XXX
+
+BO_ 792 ACC_EPS_STATE: 8 XXX
+ SG_ LKAS_Prepared : 0|1@1+ (1,0) [0|1] "" XXX
+ SG_ CruiseActivated : 1|1@1+ (1,0) [0|1] "" XXX
+ SG_ TorqueFailed : 2|1@1+ (1,0) [0|1] "" XXX
+ SG_ SETME1_0x1 : 3|1@1+ (1,0) [0|1] "" XXX
+ SG_ SteerWarning : 4|1@1+ (1,0) [0|1] "" XXX
+ SG_ SteerErrorCode : 5|3@1+ (1,0) [0|1] "" XXX
+ SG_ MainTorque : 8|12@1- (1,0) [-2048|2047] "" XXX
+ SG_ SETME3_0x1 : 20|1@1+ (1,0) [0|1] "" XXX
+ SG_ ReportHandsNotOnSteeringWheel : 21|1@1+ (1,0) [0|1] "" XXX
+ SG_ SETME4_0x3 : 22|2@1+ (1,0) [0|15] "" XXX
+ SG_ SteerDriverTorque : 24|12@1- (1,0) [-2048|2047] "" XXX
+ SG_ SETME5_0xFF : 36|4@1+ (1,0) [0|15] "" XXX
+ SG_ SETME6_0xFFF : 40|12@1+ (1,0) [0|4095] "" XXX
+ SG_ Counter : 52|4@1+ (1,0) [0|15] "" XXX
+ SG_ CheckSum : 56|8@1+ (1,0) [0|255] "" XXX
+
+BO_ 813 ACC_HUD_ADAS: 8 XXX
+ SG_ SetSpeed : 0|9@1+ (0.5,0) [0|255.5] "" XXX
+ SG_ HasLead : 9|1@1+ (1,0) [0|1] "" XXX
+ SG_ SetDistance : 10|3@1+ (1,0) [0|7] "" XXX
+ SG_ LeadingDistance : 13|3@1+ (1,0) [0|7] "" XXX
+ SG_ AEB : 16|1@1+ (1,0) [0|1] "" XXX
+ SG_ FCW : 17|1@1+ (1,0) [0|1] "" XXX
+ SG_ SETME1_0x1 : 18|1@1+ (1,0) [0|1] "" XXX
+ SG_ AccState : 19|3@1+ (1,0) [0|1] "" XXX
+ SG_ AccOn1 : 22|1@0+ (1,0) [0|1] "" XXX
+ SG_ CloseWarning : 23|1@0+ (1,0) [0|1] "" XXX
+ SG_ SETME2_0x1 : 24|1@1+ (1,0) [0|1] "" XXX
+ SG_ Notify : 25|7@1+ (1,0) [0|127] "" XXX
+ SG_ Status : 32|4@1+ (1,0) [0|15] "" XXX
+ SG_ SETME3_0xFFF : 36|12@1+ (1,0) [0|4095] "" XXX
+ SG_ Counter : 48|4@1+ (1,0) [0|15] "" XXX
+ SG_ SETME4_0xF : 55|4@0+ (1,0) [0|15] "" XXX
+ SG_ CheckSum : 56|8@1+ (1,0) [0|255] "" XXX
+
+BO_ 814 ACC_CMD: 8 XXX
+ SG_ AccelCmd : 0|8@1+ (0.05,-5) [-100|155] "" XXX
+ SG_ ComfortBandUpper : 8|8@1+ (0.05,-5) [0|1.26] "" XXX
+ SG_ ComfortBandLower : 16|8@1+ (0.05,-5) [0|1.26] "" XXX
+ SG_ JerkUpperLimit : 24|7@1+ (0.2,0) [0|12.7] "" XXX
+ SG_ SETME1_0x1 : 31|1@0+ (1,0) [0|1] "" XXX
+ SG_ JerkLowerLimit : 32|7@1+ (0.2,-16) [0|12.7] "" XXX
+ SG_ ResumeFromStandstill : 39|1@0+ (1,0) [0|1] "" XXX
+ SG_ StandstillState : 40|1@0+ (1,0) [0|1] "" XXX
+ SG_ BrakeBehaviour : 41|2@1+ (1,0) [0|3] "" XXX
+ SG_ AccReqNotStandstill : 43|1@1+ (1,0) [0|1] "" XXX
+ SG_ AccControlActive : 44|1@0+ (1,0) [0|1] "" XXX
+ SG_ AccOverrideOrStandstill : 45|1@0+ (1,0) [0|1] "" XXX
+ SG_ EspBehaviour : 46|2@1+ (1,0) [0|3] "" XXX
+ SG_ Counter : 48|4@1+ (1,0) [0|15] "" XXX
+ SG_ SETME2_0xF : 55|4@0+ (1,0) [0|15] "" XXX
+ SG_ CheckSum : 56|8@1+ (1,0) [0|255] "" XXX
+
+BO_ 815 ACC_AEB: 8 XXX
+ SG_ Counter : 48|4@1+ (1,0) [0|15] "" XXX
+ SG_ SETME_0xF : 55|4@0+ (1,0) [0|15] "" XXX
+ SG_ CheckSum : 56|8@1+ (1,0) [0|255] "" XXX
+
+BO_ 834 PEDAL: 8 XXX
+ SG_ AcceleratorPedal : 0|8@1+ (0.01,0) [0|2.55] "" XXX
+ SG_ BrakePedal : 8|8@1+ (0.01,0) [0|2.55] "" XXX
+ SG_ ForceGeneratorMode : 19|1@1+ (1,0) [0|1] "" XXX
+ SG_ DriveMode : 20|2@1+ (1,0) [0|255] "" XXX
+ SG_ PowerMode : 28|2@1+ (1,0) [0|1] "" XXX
+ SG_ CheckSum : 56|8@1+ (1,0) [0|255] "" XXX
+
+BO_ 884 RADAR_MRR: 8 XXX
+ SG_ TargetID : 1|2@0+ (1,0) [0|3] "" XXX
+ SG_ Type : 7|4@0+ (1,0) [0|15] "" XXX
+ SG_ LatDist : 15|8@0+ (0.1,-12) [0|255] "" XXX
+ SG_ LongDist : 23|8@0+ (1,-100) [0|255] "" XXX
+ SG_ IsValid : 40|1@0+ (1,0) [0|3] "" XXX
+ SG_ Counter : 52|4@1+ (1,0) [0|15] "" XXX
+ SG_ CheckSum : 56|8@1+ (1,0) [0|255] "" XXX
+
+BO_ 944 PCM_BUTTONS: 8 XXX
+ SG_ SETME_1 : 2|1@0+ (1,0) [0|1] "" XXX
+ SG_ BTN_AccUpDown_Cmd : 4|2@0+ (1,0) [0|3] "" XXX
+ SG_ BTN_AccCancel : 6|1@0+ (1,0) [0|1] "" XXX
+ SG_ BTN_TOGGLE_ACC_OnOff : 8|1@0+ (1,0) [0|1] "" XXX
+ SG_ SETME2_1 : 12|1@0+ (1,0) [0|1] "" XXX
+ SG_ BTN_AccDistanceDecrease : 15|1@0+ (1,0) [0|1] "" XXX
+ SG_ BTN_AccDistanceIncrease : 16|1@0+ (1,0) [0|1] "" XXX
+ SG_ Counter : 52|4@1+ (1,0) [0|15] "" XXX
+ SG_ CheckSum : 56|8@1+ (1,0) [0|255] "" XXX
+
+BO_ 1048 BSD_RADAR: 8 XXX
+ SG_ LEFT_APPROACH : 9|2@0+ (1,0) [0|1] "" XXX
+ SG_ RIGHT_APPROACH : 11|2@0+ (1,0) [0|1] "" XXX
+ SG_ APPROACH : 17|1@0+ (1,0) [0|1] "" XXX
+
+VAL_ 578 Gear 4 "D" 2 "R" 3 "N" 1 "P" ;
+VAL_ 790 AutoFullBeamState 11 "AutoFullBeamActive" 2 "AutoFullBeamInactive" ;
+VAL_ 790 LeftLaneState 0 "GRAY" 1 "GREEN" 2 "YELLOW" 3 "RED" ;
+VAL_ 790 LKAS_Config 3 "ALARM_AND_LKA" 2 "LKA" 1 "ALARM" 0 "DISABLE" ;
+VAL_ 790 RightLaneState 0 "GRAY" 1 "GREEN" 2 "YELLOW" 3 "RED" ;
+VAL_ 790 LKAS_AlarmType 0 "VIBRATION" 1 "AUDIO" 2 "AUDIO_AND_VIBRATION" ;
+VAL_ 813 SetDistance 4 "4BAR" 3 "3BAR" 2 "2BAR" 1 "1BAR" ;
+VAL_ 813 AccState 0 "OFF" 2 "ACC_ON" 3 "ACC_ACTIVE" 5 "FORCE_ACCEL" 7 "ERROR" ;
+VAL_ 813 Notify 36 "ACC_ERROR" 22 "OVERRIDE" 12 "ENGAGE" 8 "DISENGAGE" 20 "ACC_ON" 32 "ACC_OFF" 48 "CHECK_GEAR_D" 16 "FORCE_ACCEL" 0 "NONE" ;
+VAL_ 834 DriveMode 2 "SPORT" 1 "ECO" 0 "SNOW" ;
+VAL_ 834 PowerMode 3 "HEV" 2 "FORCE_EV" 1 "EV" ;
+VAL_ 944 BTN_AccUpDown_Cmd 0 "NOTPRESSED" 1 "DOWN_SETSPEED" 3 "UP_RESETSPEED" ;
+
diff --git a/opendbc/safety/safety.h b/opendbc/safety/safety.h
index 437e8da6..3a3a9739 100644
--- a/opendbc/safety/safety.h
+++ b/opendbc/safety/safety.h
@@ -21,6 +21,7 @@
 #include "safety/safety_volkswagen_pq.h"
 #include "safety/safety_elm327.h"
 #include "safety/safety_body.h"
+#include "safety/safety_byd.h"
 
 // CAN-FD only safety modes
 #ifdef CANFD
@@ -56,6 +57,7 @@
 #define SAFETY_HYUNDAI_CANFD 28U
 #define SAFETY_RIVIAN 33U
 #define SAFETY_VOLKSWAGEN_MEB 34U
+#define SAFETY_BYD 35U
 
 uint32_t GET_BYTES(const CANPacket_t *msg, int start, int len) {
   uint32_t ret = 0U;
@@ -415,6 +417,7 @@ int set_safety_hooks(uint16_t mode, uint16_t param) {
     {SAFETY_BODY, &body_hooks},
     {SAFETY_FORD, &ford_hooks},
     {SAFETY_RIVIAN, &rivian_hooks},
+    {SAFETY_BYD, &byd_hooks},
 #ifdef CANFD
     {SAFETY_HYUNDAI_CANFD, &hyundai_canfd_hooks},
 #endif
diff --git a/opendbc/safety/safety/safety_byd.h b/opendbc/safety/safety/safety_byd.h
new file mode 100644
index 00000000..dcffed98
--- /dev/null
+++ b/opendbc/safety/safety/safety_byd.h
@@ -0,0 +1,213 @@
+#pragma once
+
+#include "safety_declarations.h"
+
+#define BYD_CANADDR_IPB               0x1F0
+#define BYD_CANADDR_ACC_MPC_STATE     0x316
+#define BYD_CANADDR_ACC_EPS_STATE     0x318
+#define BYD_CANADDR_ACC_HUD_ADAS      0x32D
+#define BYD_CANADDR_ACC_CMD           0x32E
+#define BYD_CANADDR_PCM_BUTTONS       0x3B0
+#define BYD_CANADDR_DRIVE_STATE       0x242
+#define BYD_CANADDR_PEDAL             0x342
+#define BYD_CANADDR_CARSPEED          0x121
+
+#define BYD_CANBUS_ESC  0
+#define BYD_CANBUS_MRR  1
+#define BYD_CANBUS_MPC  2
+
+static bool byd_eps_cruiseactivated = false;
+
+typedef enum {
+  HAN_TANG_DMEV,
+  TANG_DMI,
+  SONG_PLUS_DMI,
+  QIN_PLUS_DMI,
+  YUAN_PLUS_DMI_ATTO3
+} BydPlatform;
+static BydPlatform byd_platform;
+
+static void byd_rx_hook(const CANPacket_t *to_push) {
+  int bus = GET_BUS(to_push);
+  int addr = GET_ADDR(to_push);
+  if (bus == BYD_CANBUS_ESC) {
+    if (addr == BYD_CANADDR_PEDAL) {
+      gas_pressed = (GET_BYTE(to_push, 0) != 0U);
+      brake_pressed = (GET_BYTE(to_push, 1) != 0U);
+    } else if (addr == BYD_CANADDR_CARSPEED) {
+      int speed_raw = (((GET_BYTE(to_push, 1) & 0x0FU) << 8) | GET_BYTE(to_push, 0));
+      vehicle_moving = (speed_raw != 0);
+    } else if (addr == BYD_CANADDR_ACC_EPS_STATE) {
+      byd_eps_cruiseactivated = GET_BIT(to_push, 1U) != 0U; // CruiseActivated
+      int torque_motor = (((GET_BYTE(to_push, 2) & 0x0FU) << 8) | GET_BYTE(to_push, 1)); // MainTorque
+      if ( torque_motor >= 2048 )
+        torque_motor -= 4096;
+      update_sample(&torque_meas, torque_motor);
+    }
+    else {
+      //empty
+    }
+  } else if (bus == BYD_CANBUS_MPC) {
+    if (addr == BYD_CANADDR_ACC_HUD_ADAS) {
+      unsigned int accstate = ((GET_BYTE(to_push, 2) >> 3) & 0x07U);
+      bool cruise_engaged = (accstate == 3U) || (accstate == 5U); // 3=acc_active, 5=user force accel
+      pcm_cruise_check(cruise_engaged);
+    }
+  }
+  else {
+    //empty
+  }
+}
+
+
+static bool byd_tx_hook(const CANPacket_t *to_send) {
+  const TorqueSteeringLimits HAN_DMEV_STEERING_LIMITS = {
+    .max_torque = 300,
+    .max_rate_up = 17,
+    .max_rate_down = 17,
+    .max_torque_error = 80,
+    .max_rt_delta = 243,
+    .type = TorqueMotorLimited,
+  };
+  const TorqueSteeringLimits TANG_DMI_STEERING_LIMITS = { //values to be check
+    .max_torque = 300,
+    .max_rate_up = 17,
+    .max_rate_down = 17,
+    .max_rt_delta = 243,
+    .max_torque_error = 80,
+    .type = TorqueMotorLimited,
+  };
+  const TorqueSteeringLimits SONG_STEERING_LIMITS = { //values to be check
+    .max_torque = 300,
+    .max_rate_up = 17,
+    .max_rate_down = 17,
+    .max_rt_delta = 243,
+    .max_torque_error = 80,
+    .type = TorqueMotorLimited,
+  };
+  const TorqueSteeringLimits QIN_STEERING_LIMITS = { //values to be check
+    .max_torque = 300,
+    .max_rate_up = 17,
+    .max_rate_down = 17,
+    .max_rt_delta = 243,
+    .max_torque_error = 80,
+    .type = TorqueMotorLimited,
+  };
+  const TorqueSteeringLimits YUAN_ATTO3_STEERING_LIMITS = { //values to be check
+    .max_torque = 300,
+    .max_rate_up = 17,
+    .max_rate_down = 17,
+    .max_rt_delta = 243,
+    .max_torque_error = 80,
+    .type = TorqueMotorLimited,
+  };
+
+  bool tx = true;
+  int bus = GET_BUS(to_send);
+
+  if (bus == BYD_CANBUS_ESC) {
+    int addr = GET_ADDR(to_send);
+    if (addr == BYD_CANADDR_ACC_MPC_STATE) {
+      int desired_torque = ((GET_BYTE(to_send, 3) & 0x07U) << 8U) | GET_BYTE(to_send, 2);
+      bool steer_req = GET_BIT(to_send, 28U) && byd_eps_cruiseactivated; //LKAS_Active
+      if ( desired_torque >= 1024 )
+        desired_torque -= 2048;
+      const TorqueSteeringLimits limits = (byd_platform == HAN_TANG_DMEV) ? HAN_DMEV_STEERING_LIMITS :
+                                          (byd_platform == TANG_DMI) ? TANG_DMI_STEERING_LIMITS :
+                                          (byd_platform == SONG_PLUS_DMI) ? SONG_STEERING_LIMITS :
+                                          (byd_platform == QIN_PLUS_DMI) ? QIN_STEERING_LIMITS : YUAN_ATTO3_STEERING_LIMITS;
+
+      if (steer_torque_cmd_checks(desired_torque, steer_req, limits)) {
+        tx = false;
+      }
+    }
+
+  }
+
+  return tx;
+}
+
+static bool byd_fwd_hook(int bus, int addr) {
+  bool block_msg = false;
+
+  const bool is_lkas = ((addr == BYD_CANADDR_ACC_MPC_STATE) || (addr == BYD_CANADDR_ACC_CMD));
+  const bool is_eps = (addr == BYD_CANADDR_ACC_EPS_STATE);
+
+  if ( ((bus == BYD_CANBUS_ESC) && is_eps) || ((bus == BYD_CANBUS_MPC) && is_lkas) ) {
+    block_msg = true;
+  }
+
+  return block_msg;
+}
+
+static safety_config byd_init(uint16_t param) {
+
+  const uint32_t FLAG_HAN_TANG_DMEV = 0x1U;
+  const uint32_t FLAG_TANG_DMI = 0x2U;
+  const uint32_t FLAG_SONG_PLUS_DMI = 0x4U;
+  const uint32_t FLAG_QIN_PLUS_DMI = 0x8U;
+  const uint32_t FLAG_YUAN_PLUS_DMI_ATTO3 = 0x10U;
+
+  static const CanMsg BYD_HAN_DMEV_TX_MSGS[] = {
+    {BYD_CANADDR_ACC_CMD,         BYD_CANBUS_ESC, 8, false},
+    {BYD_CANADDR_ACC_MPC_STATE,   BYD_CANBUS_ESC, 8, true},
+    {BYD_CANADDR_ACC_EPS_STATE,   BYD_CANBUS_MPC, 8, false},
+  };
+
+  static const CanMsg BYD_YUANPLUS_ATTO3_TX_MSGS[] = {
+    {BYD_CANADDR_ACC_CMD,         BYD_CANBUS_ESC, 8, false},
+    {BYD_CANADDR_ACC_MPC_STATE,   BYD_CANBUS_ESC, 8, true},
+    {BYD_CANADDR_ACC_EPS_STATE,   BYD_CANBUS_MPC, 8, false},
+  };
+
+  static RxCheck byd_han_dmev_rx_checks[] = {
+    {.msg = {{BYD_CANADDR_ACC_EPS_STATE,    BYD_CANBUS_ESC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+    {.msg = {{BYD_CANADDR_CARSPEED,         BYD_CANBUS_ESC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+    {.msg = {{BYD_CANADDR_IPB,              BYD_CANBUS_ESC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+    {.msg = {{BYD_CANADDR_DRIVE_STATE,      BYD_CANBUS_ESC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+    {.msg = {{BYD_CANADDR_ACC_HUD_ADAS,     BYD_CANBUS_MPC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+  };
+
+  // static RxCheck byd_yuanplus_atto3_rx_checks[] = {
+  //   {.msg = {{BYD_CANADDR_ACC_EPS_STATE,    BYD_CANBUS_ESC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+  //   {.msg = {{BYD_CANADDR_IPB,              BYD_CANBUS_ESC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+  //   {.msg = {{BYD_CANADDR_DRIVE_STATE,      BYD_CANBUS_ESC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+  // };
+
+  safety_config ret;
+
+  bool use_han_dm = GET_FLAG(param, FLAG_HAN_TANG_DMEV);
+  bool use_tang_dmi = GET_FLAG(param, FLAG_TANG_DMI);
+  bool use_song = GET_FLAG(param, FLAG_SONG_PLUS_DMI);
+  bool use_qin = GET_FLAG(param, FLAG_QIN_PLUS_DMI);
+  bool use_yuan = GET_FLAG(param, FLAG_YUAN_PLUS_DMI_ATTO3);
+
+  if(use_han_dm) {
+    byd_platform = HAN_TANG_DMEV;
+    ret = BUILD_SAFETY_CFG(byd_han_dmev_rx_checks, BYD_HAN_DMEV_TX_MSGS);
+  } else if (use_tang_dmi || use_song || use_qin) {
+    byd_platform = TANG_DMI;
+    ret = BUILD_SAFETY_CFG(byd_han_dmev_rx_checks, BYD_HAN_DMEV_TX_MSGS);
+  } else if (use_yuan) {
+    byd_platform = YUAN_PLUS_DMI_ATTO3;
+    static RxCheck byd_yuanplus_atto3_rx_checks[] = {
+      {.msg = {{BYD_CANADDR_ACC_EPS_STATE,    BYD_CANBUS_ESC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+      {.msg = {{BYD_CANADDR_IPB,              BYD_CANBUS_ESC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+      {.msg = {{BYD_CANADDR_DRIVE_STATE,      BYD_CANBUS_ESC, 8, .ignore_checksum = true, .ignore_counter = true, .frequency = 50U}, { 0 }, { 0 }}},
+    }; //why should I write such an ugly code just to comply with misra?
+    ret = BUILD_SAFETY_CFG(byd_yuanplus_atto3_rx_checks, BYD_YUANPLUS_ATTO3_TX_MSGS);
+  } else {
+    //should not reach here
+    byd_platform = HAN_TANG_DMEV;
+    ret = BUILD_SAFETY_CFG(byd_han_dmev_rx_checks, BYD_HAN_DMEV_TX_MSGS);
+  }
+
+  return ret;
+}
+
+const safety_hooks byd_hooks = {
+  .init = byd_init,
+  .rx = byd_rx_hook,
+  .tx = byd_tx_hook,
+  .fwd = byd_fwd_hook,
+};
diff --git a/opendbc/safety/safety_declarations.h b/opendbc/safety/safety_declarations.h
index 03b6af22..d2702a8a 100644
--- a/opendbc/safety/safety_declarations.h
+++ b/opendbc/safety/safety_declarations.h
@@ -276,6 +276,7 @@ int safety_fwd_hook(int bus_num, int addr);
 int set_safety_hooks(uint16_t mode, uint16_t param);
 
 extern const safety_hooks body_hooks;
+extern const safety_hooks byd_hooks;
 extern const safety_hooks chrysler_hooks;
 extern const safety_hooks elm327_hooks;
 extern const safety_hooks nooutput_hooks;
